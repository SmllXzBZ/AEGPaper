# Recent Papers Related To Automatic Exploit Generation
remark: This website is only used for collecting and grouping the related paper. If there are any paper need to be updated, you can contribute PR.

# All Papers (Classification according to Publication)

- **Survey/Review**
    - [软件漏洞自动利用研究进展](#软件漏洞自动利用研究进展)
    - [Crash可利用性分析方法研究综述](#Crash可利用性分析方法研究综述)
    - [The Coming Era of AlphaHacking A Survey of Automatic Software Vulnerability Detection, Exploitation and Patching Techniques](#The-Coming-Era-of-AlphaHacking-A-Survey-of-Automatic-Software-Vulnerability-Detection-Exploitation-and-Patching-Techniques)
    - [从自动化到智能化-软件漏洞挖掘技术进展](#从自动化到智能化-软件漏洞挖掘技术进展)
    - [安全漏洞自动利用综述](#安全漏洞自动利用综述)
    - [软件漏洞自动利用研究综述](#软件漏洞自动利用研究综述)
    - [自动化漏洞利用研究进展](#自动化漏洞利用研究进展)

- **Usenix 2021**
    - [EXPRACE: Exploiting Kernel Races through Raising Interrupts](#EXPRACE-Exploiting-Kernel-Races-through-Raising-Interrupts)

- **Usenix 2020**
    - [KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities](#KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities)
    - [Automatic techniques to systematically discover new heap exploitation primitives](#Automatic-techniques-to-systematically-discover-new-heap-exploitation-primitives)
    - [AURORA: Statistical Crash Analysis for Automated Root Cause Explanation](#AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation)

- **ACM SIGSAC 2020**
    - [A Generic Technique for Automatically Finding Defense-Aware Code Reuse Attacks](#A-Generic-Technique-for-Automatically-Finding-Defense-Aware-Code-Reuse-Attacks)
    - [A Systematic Study of Elastic Objects in Kernel Exploitation](#A-Systematic-Study-of-Elastic-Objects-in-Kernel-Exploitation)

- **Access 2020**
    - [HS-Pilot: Heap Security Evaluation Tool Model Based on Atomic Heap Interaction](#HS-Pilot-Heap-Security-Evaluation-Tool-Model-Based-on-Atomic-Heap-Interaction)

- **DIMVA 2020**
    - [HAEPG: An Automatic Multi-hop Exploitation Generation Framework](#HAEPG-An-Automatic-Multi-hop-Exploitation-Generation-Framework)

- **ACSAC 2020**
    - [Guide Me to Exploit: Assisted ROP Exploit Generation for ActionScript Virtual Machine](#Guide-Me-to-Exploit-Assisted-ROP-Exploit-Generation-for-ActionScript-Virtual-Machine)

- **arXiv 2020**
    - [Autosploit: A fully automated framework for evaluating the exploitability of security vulnerabilities](#Autosploit-A-fully-automated-framework-for-evaluating-the-exploitability-of-security-vulnerabilities)

- **Scientific Programming 2020**
    - [A Pattern-Based Software Testing Framework for Exploitability Evaluation of Metadata Corruption Vulnerabilities](#A-Pattern-Based-Software-Testing-Framework-for-Exploitability-Evaluation-of-Metadata-Corruption-Vulnerabilities)

- **现代计算机**
    - [基于Crash的漏洞利用自动生成系统](#基于Crash的漏洞利用自动生成系统)

- **Usenix 2019**
    - [KEPLER: Facilitating Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities](#KEPLER-Facilitating-Control-flow-Hijacking-Primitive-Evaluation-for-Linux-Kernel-Vulnerabilities)

- **ACM SIGSAC 2019**
    - [SLAKE:Facilitating slab manipulation for exploiting vulnerabilities in the linux kernel](#SLAKE-Facilitating-slab-manipulation-for-exploiting-vulnerabilities-in-the-linux-kernel)
    - [Gollum: Modular and greybox exploit generation for heap overflows in interpreters](#Gollum-Modular-and-greybox-exploit-generation-for-heap-overflows-in-interpreters)

- **计算机应用与软件 2019**
    - [基于符号执行的缓冲区溢出漏洞自动化利用](#基于符号执行的缓冲区溢出漏洞自动化利用)

- **IOP 2019**
    - [Analysis to Heap Overflow Exploit in Linux with Symbolic Execution](#Analysis-to-Heap-Overflow-Exploit-in-Linux-with-Symbolic-Execution)

- **ICSTW 2019**
    - [Automatic Generation of Capability Leaks' Exploits for Android Applications](#Automatic-Generation-of-Capability-Leaks-Exploits-for-Android-Applications)

- **计算机科学 2019**
    - [基于符号执行的 Return-to-dl-resolve 利用代码自动生成方法](#基于符号执行的Return-to-dl-resolve利用代码自动生成方法)

- **Cybersecurity 2019**
    - [From proof-of-concept to exploitable (One step towards automatic exploitability assessment)](#From-proof-of-concept-to-exploitable-One-step-towards-automatic-exploitability-assessment)

- **Acess 2019**
    - [ARG: Automatic ROP Chains Generation](#ARG-Automatic-ROP-Chains-Generation)

- **计算机研究与发展**
    - [有限资源条件下的软件漏洞自动挖掘与利用](#有限资源条件下的软件漏洞自动挖掘与利用)

- **Usenix 2018**
    - [teether: Gnawing at ethereum to automatically exploit smart contracts](#teether-Gnawing-at-ethereum-to-automatically-exploit-smart-contracts)
    - [NAVEX: Precise and scalable exploit generation for dynamic web applications](#NAVEX-Precise-and-scalable-exploit-generation-for-dynamic-web-applications)
    - [Automatic heap layout manipulation for exploitation](#Automatic-heap-layout-manipulation-for-exploitation)
    - [FUZE: Towards facilitating exploit generation for kernel use-after-free vulnerabilities](#FUZE-Towards-facilitating-exploit-generation-for-kernel-use-after-free-vulnerabilities)
    - [Heaphopper: Bringing bounded model checking to heap implementation security](#Heaphopper-Bringing-bounded-model-checking-to-heap-implementation-security)

- **ACSAC 2018**
    - [Towards automated generation of exploitation primitives for web browsers](#Towards-automated-generation-of-exploitation-primitives-for-web-browsers)

- **ACM SIGSAC 2018**
    - [Block oriented programming: Automating data-only attacks](#Block-oriented-programming-Automating-data-only-attacks)

- **ACM MICRO 2018**
    - [End-to-end automated exploit generation for validating the security of processor designs](#End-to-end-automated-exploit-generation-for-validating-the-security-of-processor-designs)
    - [Revery: From proof-of-concept to exploitable](#Revery-From-proof-of-concept-to-exploitable)

- **IEEE QRS-C 2018**
    - [Automatic exploit generation for buffer overflow vulnerability](#Automatic-exploit-generation-for-buffer-overflow-vulnerability)

- **IEEE TrustCom 2018**
    - [Pangr: A Behavior-Based Automatic Vulnerability Detection and Exploitation Framework](#Pangr-A-Behavior-Based-Automatic-Vulnerability-Detection-and-Exploitation-Framework)

- **SAI 2018**
    - [Survey of automated vulnerability detection and exploit generation techniques in cyber reasoning systems](#Survey-of-automated-vulnerability-detection-and-exploit-generation-techniques-in-cyber-reasoning-systems)

- **IEEE S&P 2017**
    - [Your exploit is mine: Automatic shellcode transplant for remote exploits](#Your-exploit-is-mine-Automatic-shellcode-transplant-for-remote-exploits)

- **NDSS 2017**
    - [Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying](#Unleashing-Use-Before-Initialization-Vulnerabilities-in-the-Linux-Kernel-Using-Targeted-Stack-Spraying)

- **ACSAC 2017**
    - [System service call-oriented symbolic execution of android framework with applications to vulnerability discovery and exploit generation](#System-service-call-oriented-symbolic-execution-of-android-framework-with-applications-to-vulnerability-discovery-and-exploit-generation)

- **PLAS 2017**
    - [Modular synthesis of heap exploits](#Modular-synthesis-of-heap-exploits)

- **ASE 2017**
    - [Automatically assessing crashes from heap overflows](#Automatically-assessing-crashes-from-heap-overflows)

- **FSE 2017**
    - [Automatic generation of inter-component communication exploits for Android applications](#Automatic-generation-of-inter-component-communication-exploits-for-Android-applications)

- **IEEE Transations 2017**
    - [Automatic generation of tests to exploit XML injection vulnerabilities in web applications](#Automatic-generation-of-tests-to-exploit-XML-injection-vulnerabilities-in-web-applications)

- **AIP 2017**
    - [Construct exploit constraint in crash analysis by bypassing canary](#Construct-exploit-constraint-in-crash-analysis-by-bypassing-canary)

- **计算机系统应用 2017**
    - [基于符号执行的自动利用生成系统](#基于符号执行的自动利用生成系统)

- **IEEE S&P 2016**
    - [Sok: state of the art of war Offensive techniques in binary analysis](#Sok-state-of-the-art-of-war-Offensive-techniques-in-binary-analysis)
    - [Data-oriented programming: On the expressiveness of non-control data attacks](#Data-oriented-programming-On-the-expressiveness-of-non-control-data-attacks)

- **ACM SIGSAC 2016**
    - [Chainsaw: Chained automated workflow-based exploit generation](#Chainsaw-Chained-automated-workflow-based-exploit-generation)

- **WISA 2016**
    - [Towards Automated Exploit Generation for Embedded Systems](#Towards-Automated-Exploit-Generation-for-Embedded-Systems)

- **KSII 2016**
    - [Deduplication and Exploitability Determination of UAF Vulnerability Samples by Fast Clustering](#Deduplication-and-Exploitability-Determination-of-UAF-Vulnerability-Samples-by-Fast-Clustering)

- **计算机应用研究**
    - [基于指针时空分析的软件异常可利用性判定](#基于指针时空分析的软件异常可利用性判定)

- **Usenix 2015**
    - [Automatic generation of data-oriented exploits](#Automatic-generation-of-data-oriented-exploits)

- **CCS 2015**
    - [From Collision To Exploitation Unleashing Use-After-Free Vulnerabilities in Linux Kernel](#From-Collision-To-Exploitation-Unleashing-Use-After-Free-Vulnerabilities-in-Linux-Kernel)

- **BlackHat 2015**
    - [Static Detection and Automatic Exploitation of Intent Message Vulnerabilities in Android Applications](#Static-Detection-and-Automatic-Exploitation-of-Intent-Message-Vulnerabilities-in-Android-Applications)

- **IFIP 2015**
    - [Exploit generation for information flow leaks in object-oriented programs](#Exploit-generation-for-information-flow-leaks-in-object-oriented-programs)

- **CODASPY 2015**
    - [Practical Exploit Generation for Intent Message Vulnerabilities in Android](#Practical-Exploit-Generation-for-Intent-Message-Vulnerabilities-in-Android)

- **Programming and Computer Software 2015**
    - [Automated Exploit Generation for Stack Buffer Overflow Vulnerabilities](#Automated-Exploit-Generation-for-Stack-Buffer-Overflow-Vulnerabilities)

- **中国科学院大学学报 2015**
    - [基于模拟攻击的内核提权漏洞自动利用系统](#基于模拟攻击的内核提权漏洞自动利用系统)

- **Usenix 2014**
    - [ROP is Still Dangerous: Breaking Modern Defenses](#ROP-is-Still-Dangerous-Breaking-Modern-Defenses)

- **CACM 2014**
    - [Automatic exploit generation](#Automatic-exploit-generation)

- **3PGCIC 2014**
    - [Program crash analysis based on taint analysis](#Program-crash-analysis-based-on-taint-analysis)

- **IEEE Transactions on Reliability 2014**
    - [Software Crash Analysis for Automatic Exploit Generation on Binary Programs](#Software-Crash-Analysis-for-Automatic-Exploit-Generation-on-Binary-Programs)

- **Reliability Digest 2014**
    - [Exploit Generation from Software Failures](#Exploit-Generation-from-Software-Failures)

- **SERE 2013**
    - [Craxweb: Automatic web application testing and attack generation](#Craxweb-Automatic-web-application-testing-and-attack-generation)

- **SecureComm 2013**
    - [Automatic polymorphic exploit generation for software vulnerabilities](#Automatic-polymorphic-exploit-generation-for-software-vulnerabilities)

- **USB/EECS 2013**
    - [Transformation-aware Exploit Generation using a HI-CFG](#Transformation-aware-Exploit-Generation-using-a-HI-CFG)

- **IEEE S&P 2012**
    - [Unleashing mayhem on binary code](#Unleashing-mayhem-on-binary-code)

- **SERE 2012**
    - [Crax: Software crash analysis for automatic exploit generation by modeling attacks as symbolic continuations](#Crax-Software-crash-analysis-for-automatic-exploit-generation-by-modeling-attacks-as-symbolic-continuations)

- **CCS 2011**
    - [Waptec: whitebox analysis of web applications for parameter tampering exploit construction](#Waptec-whitebox-analysis-of-web-applications-for-parameter-tampering-exploit-construction)

- **Usenix 2011**
    - [Q: Exploit Hardening Made Easy](#Q-Exploit-Hardening-Made-Easy)

- **NDSS 2011**
    - [AEG: Automatic exploit generation](#AEG-Automatic-exploit-generation)

- **ASIACCS 2011**
    - [Automatic construction of jump-oriented programming shellcode (on the x86)](#Automatic-construction-of-jump-oriented-programming-shellcode-on-the-x86)

- **Blackhat 2010**
    - [Crash analysis with BitBlaze](#Crash-analysis-with-BitBlaze)

- **Usenix 2009**
    - [Return-Oriented Rootkits: Bypassing Kernel Code Integrity Protection Mechanisms](#Return-OrientedRootkits-Bypassing-Kernel-Code-Integrity-Protection-Mechanisms)

- **ICSE 2009**
    - [Automatic creation of SQL Injection and cross-site scripting attacks](#Automatic-creation-of-SQL-Injection-and-cross-site-scripting-attacks)

- **Oxford 2009**
    - [Automatic generation of control flow hijacking exploits for software vulnerabilities](#Automatic-generation-of-control-flow-hijacking-exploits-for-software-vulnerabilities)

- **IEEE S&P 2008**
    - [Automatic patch-based exploit generation is possible: Techniques and implications](#Automatic-patch-based-exploit-generation-is-possible-Techniques-and-implications)

- **Usenix 2008**
    - [Automatic Generation of XSS and SQL Injection Attacks with Goal-Directed Model Checking](#Automatic-Generation-of-XSS-and-SQL-Injection-Attacks-with-Goal-Directed-Model-Checking)

- **Usenix 2005**
    - [Automating Mimicry Attacks Using Static Binary Analysis](#Automating-Mimicry-Attacks-Using-Static-Binary-Analysis)

# Survey/Review

### 软件漏洞自动利用研究进展

* <img src="image/pdf_24px.png">[Paper](./paper/2016软件漏洞自动利用研究进展.pdf)

**Abstract:** 软件漏洞发掘是当前的热点问题。尽管模糊测试技术帮助我们解决了程序漏洞的自动发现问题，并行模糊测试平台已经可以高效的发现大量的程序错误，但无论是防御者还是攻击者，都更关心这些程序漏洞或错误是否可能被利用。如何快速分析、评估漏洞的可利用性是当前漏洞发掘与分析的关键问题之一。传统软件漏洞利用主要以手工方式构造，该过程不仅需要具备较为全面的系统底层知识（包括文件格式，汇编代码，操作系统内部机理以及处理器架构等），同时还需要对漏洞机理深入、细致的分析，才可能构造成功的利用。目前，随着程序分析技术的不断发展，尤其是污点分析、符号执行等技术成功运用在软件动态分析以及软件漏洞挖掘等多个领域后，研究者开始尝试利用这些技术来进行高效的软件漏洞利用自动构造。
  
### Crash可利用性分析方法研究综述

* <img src="image/pdf_24px.png">[Paper](./paper/2018Crash可利用性分析方法研究综述.pdf)

**Abstract:** Fuzzing技术是现阶段用于漏洞挖掘的主流技术,目前绝大多数的软件漏洞都是利用该技术发现的.但是
Fuzzing技术存在的一个主要问题是其会产生大量的crash样本,如何对这些crash样本进行快速的分析分类,是当前基于Fuzzing技术进行漏洞挖掘工作所面临的主要问题. 针对crash可利用性分析的研究,首先,总结了导致程序crash的原因并对其分析技术发展的现状进行了概述;其次,着重分析了当前利用动态污点分析和符号执行等技术进行crash可利用性判定的４种有效分析方法;最后,对比了这４种方法之间的差异,并探讨了crash可利用性分析技术未来的发展方向及趋势.

### The Coming Era of AlphaHacking A Survey of Automatic Software Vulnerability Detection, Exploitation and Patching Techniques

* <img src="image/pdf_24px.png">[Paper](./paper/2018The%20Coming%20Era%20of%20AlphaHacking--%20A%20Survey%20of%20Automatic%20Software%20Vulnerability%20Detection,%20Exploitation%20and%20Patching%20Techniques.pdf)

**Abstract:** With the success of the Cyber Grand Challenge (CGC) sponsored by DARPA, the topic of Autonomous Cyber Reasoning System (CRS) has recently attracted extensive attention from both industry and academia. Utilizing automated system to detect, exploit and patch software vulnerabilities seems so attractive because of its scalability and cost-efficiency compared with the human expert based solution. In this paper, we give an extensive survey of former representative works related to the underlying technologies of a CRS, including vulnerability detection, exploitation and patching. As an important supplement, we then review several pioneer studies that explore the potential of machine learning technologies in this field, and point out that the future development of Autonomous CRS is inseparable from machine learning.

### 从自动化到智能化-软件漏洞挖掘技术进展

* <img src="image/pdf_24px.png">[Paper](./paper/2018从自动化到智能化-软件漏洞挖掘技术进展.pdf)

**Abstract:** 近年来,随着软件规模和复杂度的日益增加,软件漏洞挖掘技术正逐渐向高度自动化和智能化演变,该文从传统漏洞挖掘技术和基于学习的智能化漏洞挖掘技术两方面深入调研和分析了相关的研究进展.首先,从静态和动态挖掘技术２方面详细介绍了传统漏洞挖掘技术的研究现状,涉及的技术包括模型检测、二进制比对、模糊测试、符号执行以及漏洞可利用性分析等,并分析了各项技术存在的问题,提出当前的研究难点是实现漏洞挖掘全自动化.然后,介绍了机器学习和深度学习技术在漏洞挖掘领域的应用,具体应用场景包括二进制函数识别、函数相似性检测、测试输入生成、路径约束求解等,并提出了其存在的机器学习算法不够健壮安全、算法选择依靠经验、数据样本不足、特征选择依赖专家知识等问题.最后,对未来研究工作进行了展
望,提出应该围绕提高漏洞挖掘的精度和效率、提高自动化和智能化的程度这２方面展开工作.

### 安全漏洞自动利用综述

* <img src="image/pdf_24px.png">[Paper](./paper/2019安全漏洞自动利用综述_赵尚儒.pdf)

**Abstract:** 随着安全漏洞数量急剧上升，高效率地评估与修复漏洞面临更大的挑战．目前漏洞的可利用性评估主要依赖人工方法，如何智能化和自动化地进行安全漏洞利用是本领域一个热点研究问题．调研了2006年至今安全漏洞自动利用文献，分析了现状并指出了漏洞利用研究的发展趋势，同时给出了漏洞自动利用的一般框架；分别从漏洞自动利用的信息输入、漏洞类型和利用方法这3个角度对当前研究成果进行了梳理，指出了这3个角度对漏洞自动利用的影响；分析了漏洞自动利用研究的不足与挑战，并对将来的研究趋势进行了展望．

### 软件漏洞自动利用研究综述

* <img src="image/pdf_24px.png">[Paper](./paper/2019软件漏洞自动利用研究综述.pdf)

**Abstract:** 近年来，软件漏洞已成为系统安全与攻防对抗的核心要素，随着软件数量的增加和规模的复杂化，漏洞数量逐年增加，而依赖于人工的漏洞分析与利用生成已难以满足现实需求，漏洞的自动分析和利用生成是亟待解决的难点问题．现有研究已经取得了相关的成果，文章从控制流劫持漏洞自动利用、面向堆漏洞的自动分析与利用、安全机制自动化对抗方法和综合性的漏洞自动利用框架等四个方面介绍当前软件漏洞自动利用研究进展，进而分析未来软件漏洞自动利用发展趋势．

### 自动化漏洞利用研究进展

* <img src="image/pdf_24px.png">[Paper](./paper/2019自动化漏洞利用研究进展_靳宪龙.pdf)

**Abstract:** 网络空间安全斗争形式日趋复杂，针对软件安全的攻防博弈愈演愈烈。软件漏洞挖掘与利用的复杂性及专业性，使得大量工作仅能依靠安全专家完成。近年来，漏洞数量激增，仅依靠安全专家已无法有效应对。自动化漏洞利用应运而生，该方法在提升工作效率的同时降低人力成本，并一定程度上满足了自动化攻防的迫切需求。介绍自动化漏洞利用相关概念，对关键技术进行归纳与总结，梳理国内外主流的自动化漏洞利用系统。

### EXPRACE: Exploiting Kernel Races through Raising Interrupts

* <img src="image/pdf_24px.png">[Paper](./paper/2021EXPRACE%20Exploiting%20Kernel%20Races%20through%20Raising%20Interrupts.pdf)

**Abstract:** A kernel data race is notoriously challenging to detect, reproduce, and diagnose, mainly caused by nondeterministic thread interleaving. The kernel data race has a critical security implication since it often leads to memory corruption, which can be abused to launch privilege escalation attacks. Interestingly, due to the challenges above, the exploitation of the kernel data race is also challenging. Specifically, we find that some kernel races are nearly impossible to exploit due to their unique requirement on execution orders, which are almost impossible to happen without manual intervention.    
<p style="text-align:justify;text-justify:inter-ideograph;">This paper develops a generic exploitation technique for kernel data races. To this end, we first analyze kernel data races, which finds an intrinsic condition classifying easy-to-exploit and hard-to-exploit races. Then we develop EXPRACE, a generic race exploitation technique for modern kernels, including Linux, Microsoft Windows, and MAC OS X. EXPRACE turns hard-to-exploit races into easy-toexploit races by manipulating an interrupt mechanism during the exploitation. According to our evaluation with 10 realworld hard-to-exploit races, EXPRACE was able to exploit all of those within 10 to 118 seconds, while an exploitation without EXPRACE failed for all given 24 hours.</p>

### A Generic Technique for Automatically Finding Defense-Aware Code Reuse Attacks

* <img src="image/pdf_24px.png">[Paper](./paper/2020A%20Generic%20Technique%20for%20Automatically%20Finding%20Defense-Aware%20Code%20Reuse%20Attacks.pdf)

**Abstract:** Code reuse attacks have been the subject of a substantial amount of research during the past decade. This research largely resulted from early work on Return-Oriented Programming (ROP), which showed that the then newly proposed Non-Executable Memory (NX) defense could be bypassed. More recently, the research community has been simultaneously investigating new defenses that are believed
to thwart code reuse attacks, such as Control Flow Integrity (CFI), and defense-aware techniques for attacking these defenses, such as Data-Oriented Programming (DOP). Unfortunately, the feasibility of defense-aware attacks are very dependent on the behaviors of the attacked program, which makes it difficult for defenders to understand how much protection a defense such as CFI may provide. To better understand this, researchers have introduced automated defense-aware code reuse attack systems. Unfortunately, the handful of existing systems implement a single fixed, defense-specific strategy that is complex and cannot be used to consider other defenses.   
In this paper, we propose a generic framework for automatically discovering defense-aware code reuse attacks in executables. Unlike existing work, which utilizes hard-coded strategies for specific defenses, our framework can produce attacks for multiple defenses by analyzing the runtime behavior of the defense. The high-level insight behind our framework is that code reuse attacks can be defined as a state reachability problem, and that defenses prevent some transitions between states.We implement our framework as a tool named Limbo, which employs an existing binary concolic executor to solve the reachability problem.We evaluate Limbo and show that it excels when there is little code available for reuse, making it complementary to existing techniques.We show that, in such scenarios, Limbo outperforms existing systems that automate ROP attacks, as well as systems that automate DOP attacks in the presence of fine-grained CFI, despite having no special knowledge about ROP or DOP attacks.

### A Pattern-Based Software Testing Framework for Exploitability Evaluation of Metadata Corruption Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2020A%20Pattern-Based%20Software%20Testing%20Framework%20for%20Exploitability%20Evaluation%20of%20Metadata%20Corruption%20Vulnerabilities.pdf)

**Abstract:** In recent years, increased attention is being given to software quality assurance and protection. With considerable verification and protection schemes proposed and deployed, today’s software unfortunately still fails to be protected from cyberattacks, especially in the presence of insecure organization of heap metadata. In this paper, we aim to explore whether heap metadata could be corrupted and exploited by cyberattackers, in an attempt to assess the exploitability of vulnerabilities and ensure software quality. To this end, we propose RELAY, a software testing framework to simulate human exploitation behavior for metadata corruption at the machine level. RELAY employs the heap layout serialization method to construct exploit patterns from human expertise and decomposes complex exploit-solving problems into a series of intermediate state-solving subproblems. With the heap layout procedural method, RELAY makes use of the fewer resources consumed to solve a layout problem according to the exploit pattern, activates the intermediate state, and generates the final exploit. Additionally, RELAY can be easily extended and can continuously assimilate human knowledge to enhance its ability for exploitability evaluation. Using 20 CTF&RHG programs, we then demonstrate that RELAY has the ability to evaluate the exploitability of metadata corruption vulnerabilities and works more efficiently compared with other state-of-the-art automated tools.

### A Systematic Study of Elastic Objects in Kernel Exploitation

* <img src="image/pdf_24px.png">[Paper](./paper/2020A%20Systematic%20Study%20of%20Elastic%20Objects%20in%20Kernel%20Exploitation.pdf)

**Abstract:** Recent research has proposed various methods to perform kernel exploitation and bypass kernel protection. For example, security researchers have demonstrated an exploitation method that utilizes the characteristic of elastic kernel objects to bypass KASLR, disclose stack/heap cookies, and even perform arbitrary read in the kernel. While this exploitation method is considered a commonly adopted approach to disclosing critical kernel information, there is no evidence indicating a strong need for developing a new defense mechanism to limit this exploitation method. It is because the effectiveness of this exploitation method is demonstrated only on anecdotal kernel vulnerabilities. It is unclear whether such a method is useful for a majority of kernel vulnerabilities.    
To answer this question, we propose a systematic approach. It utilizes static/dynamic analysis methods to pinpoint elastic kernel objects and then employs constraint solving to pair them to corresponding kernel vulnerabilities. In this work, we implement our proposed method as a tool - ELOISE. Using this tool on three popular OSes (Linux, FreeBSD, and XNU), we discover that elastic objects are pervasive in general caches. Evaluating the effectiveness of these elastic objects on 40 kernel vulnerabilities across three OSes, we observe that they can enable most of the vulnerabilities to bypass KASLR and heap cookie protector. Besides, we also observe that these elastic objects can even escalate the exploitability of some vulnerabilities allowing them to perform arbitrary read in the kernel. Motivated by these observations, we further introduce a new defense mechanism to mitigate the threat of elastic kernel objects. We prototype our defense mechanism on Linux, showing this mechanism introduces negligible overhead.

### AURORA: Statistical Crash Analysis for Automated Root Cause Explanation

* <img src="image/pdf_24px.png">[Paper](./paper/2020AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Root%20Cause%20Explanation.pdf)

**Abstract:** Given the huge success of automated software testing techniques, a large amount of crashes is found in practice. Identifying the root cause of a crash is a time-intensive endeavor, causing a disproportion between finding a crash and fixing the underlying software fault. To address this problem, various approaches have been proposed that rely on techniques such as reverse execution and backward taint analysis. Still, these techniques are either limited to certain fault types or provide an analyst with assembly instructions, but no context information or explanation of the underlying fault.   
In this paper, we propose an automated analysis approach that does not only identify the root cause of a given crashing input for a binary executable, but also provides the analyst with context information on the erroneous behavior that characterizes crashing inputs. Starting with a single crashing input, we generate a diverse set of similar inputs that either also crash the program or induce benign behavior. We then trace the program’s states while executing each found input and generate predicates, i. e., simple Boolean expressions that capture behavioral differences between crashing and noncrashing inputs. A statistical analysis of all predicates allows us to identify the predicate pinpointing the root cause, thereby not only revealing the location of the root cause, but also providing an analyst with an explanation of the misbehavior a crash exhibits at this location. We implement our approach in a tool called AURORA and evaluate it on 25 diverse software faults. Our evaluation shows that AURORA is able to uncover root causes even for complex bugs. For example, it succeeded in cases where many millions of instructions were executed between developer fix and crashing location. In contrast to existing approaches, AURORA is also able to handle bugs with no data dependency between root cause and crash, such as type confusion bugs.

### Automatic Techniques to Systematically Discover New Heap Exploitation Primitives

* <img src="image/pdf_24px.png">[Paper](./paper/2020Automatic%20Techniques%20to%20Systematically%20Discover%20New%20Heap%20Exploitation%20Primitives.pdf)

**Abstract:** Exploitation techniques to abuse the metadata of heap allocators have been widely studied because of their generality (i.e., application independent) and powerful capability (i.e., bypassing mitigation). However, such techniques are commonly considered arts, and thus the approaches to discover them remain ad-hoc, manual, and allocator-specific at best.   
In this paper, we present an automatic tool, ARCHEAP, to systematically discover the unexplored heap exploitation primitives, regardless of their underlying implementations. The key idea of ARCHEAP is to let the computer autonomously explore the spaces, similar in concept to fuzzing, by specifying a set of common designs of modern heap allocators and root causes of vulnerabilities as models, and by providing heap operations and attack capabilities as actions. During the exploration, ARCHEAP checks whether the combinations of these actions can be potentially used to construct exploitation primitives, such as arbitrary write or overlapped chunks. As a proof, ARCHEAP generates working PoC that demonstrates the discovered exploitation technique.   
We evaluated ARCHEAP with three real-world allocators (i.e., ptmalloc, tcmalloc, and jemalloc), as well as custom allocators from the DARPA Cyber Grand Challenge. As a result, ARCHEAP discovered five previously unknown exploitation primitives in ptmalloc and found several exploitation techniques against jemalloc, tcmalloc, and even custom heap allocators. To show the effectiveness of ARCHEAP’s approach in other domains, we also studied how security features evolve and which exploit primitives are effective across different versions of ptmalloc.

### Autosploit: A Fully Automated Framework for Evaluating the Exploitability of Security Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2020Autosploit%20A%20Fully%20Automated%20Framework%20for%20Evaluating.pdf)

**Abstract:** The existence of a security vulnerability in a system does not necessarily mean that it can be exploited. In this research, we introduce Autosploit —an automated framework for evaluating the exploitability of vulnerabilities. Given a vulnerable environment and relevant exploits, Autosploit will automatically test the exploits on different configurations of the environment in order to identify the specific properties necessary for successful exploitation of the existing vulnerabilities. Since testing all possible system configurations is infeasible, we introduce an efficient approach for testing and searching through all possible configurations of the environment. The efficient testing process implemented by Autosploit is based on two algorithms: generalized binary splitting and Barinel, which are used for noiseless and noisy environments respectively. We implemented the proposed framework and evaluated it using real vulnerabilities. The results show that Autosploit is able to automatically identify the system properties that affect the ability to exploit a vulnerability in both noiseless and noisy environments. These important results can be utilized for more accurate and effective risk assessment.

### Guide Me to Exploit: Assisted ROP Exploit Generation for ActionScript Virtual Machine

* <img src="image/pdf_24px.png">[Paper](./paper/2020Guide%20Me%20to%20Exploit%20Assisted%20ROP%20Exploit%20Generation%20for%20ActionScript%20Virtual%20Machine.pdf)

**Abstract:** Automatic exploit generation (AEG) is the challenge of determining the exploitability of a given vulnerability by exploring all possible execution paths that can result from triggering the vulnerability. Since typical AEG implementations might need to explore an unbounded number of execution paths, they usually utilize a fuzz tester and a symbolic execution tool to facilitate this task. However, in the case of language virtual machines, such as the ActionScript Virtual Machine (AVM), AEG implementations cannot leverage fuzz testers or symbolic execution tools for generating the exploit script, because of two reasons: (1) fuzz testers cannot efficiently generate grammatically correct executables for the AVM due to the improbability of randomly generating highly-structured executables that follow the complex grammar rules and (2) symbolic execution tools encounter the well-known program-state-explosion problem due to the enormous number of control paths in early processing stages of a language virtual machine (e.g., lexing and parsing).   
This paper presents GuidExp, a guided (semi-automatic) exploit generation tool for AVM vulnerabilities. GuidExp synthesizes an exploit script that exploits a given ActionScript vulnerability. Unlike other AEG implementations, GuidExp leverages exploit deconstruction, a technique of splitting the exploit script into many smaller code snippets. GuidExp receives hints from security experts and uses them to determine places where the exploit script can be split. Thus, GuidExp can concentrate on synthesizing these smaller code snippets in sequence to obtain the exploit script instead of synthesizing the entire exploit script at once. GuidExp does not rely on fuzz testers or symbolic execution tools. Instead, GuidExp performs exhaustive search adopting four optimization techniques to facilitate the AEG process: (1) exploit deconstruction, (2) operand stack verification, (3) instruction tiling, and (4) feedback from the AVM. A running example highlights how GuidExp synthesizes the exploit script for a real-world AVM use-after-free vulnerability. In addition, GuidExp’s successful generation of exploits for ten other AVM vulnerabilities is reported.

### HAEPG: An Automatic Multi-hop Exploitation Generation Framework

* <img src="image/pdf_24px.png">[Paper](./paper/2020HAEPG%20An%20Automatic%20Multi-hop%20Exploitation%20Generation%20Framework.pdf)

**Abstract:** Automatic exploit generation for heap vulnerabilities is an open challenge. Current studies require a sensitive pointer on the heap to hijack the control flow and pay little attention to vulnerabilities with limited capabilities. In this paper, we propose HAEPG, an automatic exploit framework that can utilize known exploitation techniques to guide exploit generation. We implemented a prototype of HAEPG based on the symbolic execution engine S2E and provided four exploitation techniques for it as prior knowledge. HAEPG takes crashing inputs, programs, and prior knowledge as input, and generates exploits for vulnerabilities with limited capabilities by abusing heap allocator’s internal functionalities.   
We evaluated HAEPG with 24 CTF programs, and the results show that HAEPG is able to accurately reason about the type of vulnerability for 21 (87.5%) of them, and generate exploits that spawn a shell for 16 (66.7%) of them. All the exploits could bypass NX and Full RELRO security mechanisms.

### HS-Pilot: Heap Security Evaluation Tool Model Based on Atomic Heap Interaction

* <img src="image/pdf_24px.png">[Paper](./paper/2020HS-Pilot%20Heap%20Security%20Evaluation%20Tool%20Model%20Based%20on%20Atomic%20Heap%20Interaction.pdf)

**Abstract:** To evaluate heap security, researchers have designed evaluation tools that automatically locate heap vulnerabilities. Most of these tools define heap interactions as heap misuses that are bugs, such as overflow in a target heap allocator, and verify whether each combination of heap interactions can be used as an exploit. However, this definition of heap interactions requires preliminary work by a user possessing evaluation tools and specialized knowledge—the user needs to manually do much work to find which heap misuses exist in the target heap allocator. In addition, because the existing heap misuses vary according to target heap allocators and versions, this preliminary work must be performed on each heap implementation. That is, the current definition of heap interaction cannot be generalized to all heap implementations.   
In this paper, we propose a novel heap security evaluation model, called Heap Security Pilot (HS-Pilot), to overcome the preliminary work load and the dependency of heap misuse in heap implementation. In HSPilot, a heap interaction is newly defined as the modification of heap metadata, based on the idea that any heap misuse can be represented by a sequence of heap metadata, i.e. combination of heap interactions used by HS-Pilot. Consequently, the heap interactions in HS-Pilot can be applied to all heap implementations without specialized knowledge, and therefore, are more general than that in existing heap evaluation tools. Our evaluation shows that HS-Pilot can cover the analysis range of other evaluation tools, and is able to detect 14 known types of heap exploitation against heap allocator ptmalloc and all types of heap exploitation found by a state-of-the-art evaluation tool.

### KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2020KOOBE%20Towards%20Facilitating%20Exploit%20Generation%20of%20Kernel%20Out-Of-Bounds%20Write%20Vulnerabilities.pdf)

**Abstract:** The monolithic nature of modern OS kernels leads to a constant stream of bugs being discovered. It is often unclear which of these bugs are worth fixing, as only a subset of them may be serious enough to lead to security takeovers (i.e., privilege escalations). Therefore, researchers have recently started to develop automated exploit generation techniques (for UAF bugs) to assist the bug triage process. In this paper, we investigate another top memory vulnerability in Linux kernel -- out-of-bounds (OOB) memory write from heap. We design KOOBE to assist the analysis of such vulnerabilities based on two observations: (1) Surprisingly often, different OOB vulnerability instances exhibit a wide range of capabilities. (2) Kernel exploits are multi-interaction in nature (i.e., multiple syscalls are involved in an exploit) which allows the exploit crafting process to be modular. Specifically, we focus on the extraction of capabilities of an OOB vulnerability which will feed the subsequent exploitability evaluation process. Our system builds on several building blocks, including a novel capability-guided fuzzing solution to uncover hidden capabilities, and a way to compose capabilities together to further enhance the likelihood of successful exploitations. In our evaluation, we demonstrate the applicability of KOOBE by exhaustively analyzing 17 most recent Linux kernel OOB vulnerabilities (where only 5 of them have publicly available exploits), for which KOOBE successfully generated candidate exploit strategies for 11 of them (including 5 that do not even have any CVEs assigned). Subsequently from these strategies, we are able to construct fully working exploits for all of them.

### 基于Crash的漏洞利用自动生成系统

* <img src="image/pdf_24px.png">[Paper](./paper/2020基于Crash的漏洞利用自动生成系统.pdf)

**Abstract:** 漏洞分析、自动化攻防对漏洞利用自动生成的需求越来越迫切，在分析现有方案的基础上，结合动态分析、混合符号执行等技术，提出基于Crash的漏洞利用自动生成方法C—Rex。该方法能够针对缓冲区溢出漏洞自动生成劫持控制流的漏洞利用样本。完成以下工作：①设计路径搜索算法复现崩溃路径并挖掘新崩溃点；②分析崩溃状态，对可利用性进行判定；③根据需求采用代码注人或代码复用技术生成劫持控制流的漏洞利用样本。通过对CTF题目及10款开源应用进行测试，C—Rex均能成功生成漏洞利用样本，证明该方法的有效性。

### Analysis to Heap Overflow Exploit in Linux with Symbolic Execution

* <img src="image/pdf_24px.png">[Paper](./paper/2019Analysis%20to%20Heap%20Overflow%20Exploit%20in%20Linux%20with%20Symbolic.pdf)

**Abstract:** Heap overflow is a common error of buffer overflow in Linux. The control flow of a program may be hijacked when the program satisfies several specific conditions. The existing automatic exploit generation technologies for buffer overflow find vulnerability trigger point and generate exploit by checking the control flow state. However, the heap overflow data rarely lead to a control flow hijacking as well as protection mechanisms limit the trigger condition. It is difficult to analyze the exploitability of heap overflow automatically through the existing analysis technology. For the heap overflow errors in Linux, we summarize the features of exploit on the basis of analyzing the instances, building the detection model of the exploitability of heap overflow, and proposing a method for analyzing the exploitability of heap overflow based on the model. The proposed method monitors the input data and insecurity functions of the program by using taint analysis; builds the path constraints and data constraints which satisfy the conditions of heap overflow exploit through selective symbolic execution; solves the abovementioned constraints and generates the test case automatically. All the steps of our method can be finished automatically by using the symbolic execution tool S2E. The experiments show that this method can automatically analyze and detect the exploitability of heap overflow errors.

### ARG: Automatic ROP chains Generation

* <img src="image/pdf_24px.png">[Paper](./paper/2019ARG%20Automatic%20ROP%20chains%20Generation.pdf)

**Abstract:** Return Oriented Programming (ROP) chains attack has been widely used to bypass Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR) protection. However, the generation technology for ROP chains is still in a state of manual coding. While, current techniques for automatically generating ROP chains are still insufficiently researched and have few successful applications. On the other hand, the existing methods are based on using Intermediate Language (IL) which is in order to translate the semantics of original instructions for symbolic execution, and then fill in a predefined gadget arrangement to automatically construct a gadget list. This kind of methods may bring following problems: (1) when converting semantics of original to IL, there is a large amount of overhead time, critical instructions may be discarded; (2) the process of populating a predetermined gadget arrangement is inflexible and may fail to construct ROP chains due to address mismatching. In this paper, we propose the Automatic ROP chains Generation (ARG) which is the first fully automatic ROP chains generation tool without using IL. Tested with data from 6 open-source international Capture The Flag (CTF) competitions and 3 Common Vulnerabilities & Exposures (CVE)s, this technology successfully generated ROP chains for all of them. According to the obtained results, our technique can automatically create ROP payloads and reduce up to 80% of ROP exploit payloads. It takes only 3-5 seconds to exploit successfully, compared to manual analysis for at least 60 minutes, as well as it can effectively bypass both Write XOR Execute (WX) and ASLR.

### Automatic Generation of Capability Leaks’ Exploits for Android Applications

* <img src="image/pdf_24px.png">[Paper](./paper/2019Automatic%20Generation%20of%20Capability%20Leaks'%20Exploits%20for%20Android%20Applications.pdf)

**Abstract:** The capability leak of Android applications is one kind of serious vulnerability. It causes other apps to leverage its functions to achieve their illegal goals. In this paper, we propose a tool which can automatically generate capability leaks’ exploits of Android applications with path-sensitive symbolic execution-based static analysis and test. It can aid in reducing false positives of vulnerability analysis and help engineers find bugs. We utilize control flow graph (CFG) reduction and call graph (CG) search optimization to optimize symbolic execution, which make our tool applicable for practical apps. By applying our tool to 439 popular applications of theWandoujia (a famous app market in China) in 2017, we found 2239 capability leaks of 16 kinds of permissions. And the average analysis time was 4 minutes per app. A demo video can be found at the website https://youtu.be/dXFMNZWxEc0.

### From proof-of-concept to exploitable (One step towards automatic exploitability assessment)

* <img src="image/pdf_24px.png">[Paper](./paper/2019From%20proof-of-concept%20to%20exploitable%20(One%20step%20towards%20automatic%20exploitability%20assessment).pdf)

**Abstract:** Exploitability assessment of vulnerabilities is important for both defenders and attackers. The ultimate way to assess the exploitability is crafting a working exploit. However, it usually takes tremendous hours and significant manual efforts. To address this issue, automated techniques can be adopted. Existing solutions usually explore in depth the crashing paths, i.e., paths taken by proof-of-concept (PoC) inputs triggering vulnerabilities, and assess exploitability by finding exploitable states along the paths. However, exploitable states do not always exist in crashing paths. Moreover, existing solutions heavily rely on symbolic execution and are not scalable in path exploration and exploit generation. In this paper, we propose a novel solution to generate exploit for userspace programs or facilitate the process of crafting a kernel UAF exploit. Technically, we utilize oriented fuzzing to explore diverging paths from vulnerability point. For userspace programs, we adopt a control-flow stitching solution to stitch crashing paths and diverging paths together to generate exploit. For kernel UAF, we leverage a lightweight symbolic execution to identify, analyze and evaluate the system calls valuable and useful for exploiting vulnerabilities. We have developed a prototype system and evaluated it on a set of 19 CTF (capture the flag) programs and 15 realworld Linux kernel UAF vulnerabilities. Experiment results showed it could generate exploit for most of the userspace test set, and it could also facilitate security mitigation bypassing and exploitability evaluation for kernel test set.

### Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters

* <img src="image/pdf_24px.png">[Paper](./paper/2019Gollum%20Automatic%20Exploit%20Generation(AEG)%20for%20Heap%20Overflows%20in%20Interpreters.pdf)

**Abstract:** We present the first approach to automatic exploit generation for heap overflows in interpreters. It is also the first approach to exploit generation in any class of program that integrates a solution for automatic heap layout manipulation. At the core of the approach is a novel method for discovering exploit primitives—inputs to the target program that result in a sensitive operation, such as a function call or a memory write, utilizing attacker-injected data. To produce an exploit primitive from a heap overflow vulnerability, one has to discover a target data structure to corrupt, ensure an instance of that data structure is adjacent to the source of the overflow on the heap, and ensure that the post-overflow corrupted data is used in a manner desired by the attacker. Our system addresses all three tasks in an automatic, greybox, and modular manner. Our implementation is called Gollum, and we demonstrate its capabilities by producing exploits from 10 unique vulnerabilities in the PHP and Python interpreters, 5 of which do not have existing public exploits.

### KEPLER: Facilitating Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2019KEPLER%20Facilitating%20Control-flow%20Hijacking%20Primitive%20Evaluation%20for%20Linux%20Kernel%20Vulnerabilities.pdf)

**Abstract:** Automatic exploit generation is a challenging problem. A challenging part of the task is to connect an identified exploitable state (exploit primitive) to triggering execution of code-reuse (e.g., ROP) payload. A control-flow hijacking primitive is one of the most common capabilities for exploitation. However, due to the challenges of widely deployed exploit mitigations, pitfalls along an exploit path, and ill-suited primitives, it is difficult to even manually craft an exploit with a control-flow hijacking primitive for an off-the-shelf modern Linux kernel. We propose KEPLER to facilitate exploit generation by automatically generating a “single-shot” exploitation chain. KEPLER accepts as input a control-flow hijacking primitive and bootstraps any kernel ROP payload by symbolically stitching an exploitation chain taking advantage of prevalent kernel coding style and corresponding gadgets. Comparisons with previous automatic exploit generation techniques and previous kernel exploit techniques show KEPLER effectively facilitates evaluation of control-flow hijacking primitives in the Linux kernel.

### SLAKE: Facilitating Slab Manipulation for Exploiting Vulnerabilities in the Linux Kernel

* <img src="image/pdf_24px.png">[Paper](./paper/2019SLAKE%20Facilitating%20Slab%20Manipulation%20for%20Exploiting%20Vulnerabilities%20in%20the%20Linux%20Kernel.pdf)

**Abstract:** To determine the exploitability for a kernel vulnerability, a security analyst usually has to manipulate slab and thus demonstrate the capability of obtaining the control over a program counter or performing privilege escalation. However, this is a lengthy process because (1) an analyst typically has no clue about what objects and system calls are useful for kernel exploitation and (2) he lacks the knowledge of manipulating a slab and obtaining the desired layout. In the past, researchers have proposed various techniques to facilitate exploit development. Unfortunately, none of them can be easily applied to address these challenges. On the one hand, this is because of the complexity of the Linux kernel. On the other hand, this is due to the dynamics and non-deterministic of slab variations. In this work, we tackle the challenges above from two perspectives. First,we use static and dynamic analysis techniques to explore the kernel objects, and the corresponding system calls useful for exploitation. Second, we model commonly-adopted exploitation methods and develop a technical approach to facilitate the slab layout adjustment. By extending LLVM as well as Syzkaller, we implement our techniques and name their combination after SLAKE. We evaluate SLAKE by using 27 real-world kernel vulnerabilities, demonstrating that it could not only diversify the ways to perform kernel exploitation but also sometimes escalate the exploitabilityof kernel vulnerabilities.

### 基于符号执行的Return-to-dl-resolve利用代码自动生成方法

* <img src="image/pdf_24px.png">[Paper](./paper/2019基于符号执行的Return_to_dl_resolve利用代码自动生成方法_方皓.pdf)

**Abstract:** Return-to-dl-resolve是一种可突破复杂防护机制的通用漏洞利用技术，目前主要以手工方式实现，研究人员需要深入分析并理解ELF动态链接原理，泄露并解析任意库函数的地址，拼装攻击载荷，效率非常低。文中提出了一种基于符号执行的Return-to-dl-resolve自动化实现方法，该方法为ELF可执行文件提供符号执行环境，对程序崩溃点的符号状态进行约束，通过约束求解器对约束进行求解，实现了Return-to-dl-resolve利用代码自动生成系统R2dlAEG。实验结果表明，R2dlAEG可快速构造利用代码，并能够在NX和ASLR防护机制同时开启的条件下劫持程序的控制流。

### 基于符号执行的缓冲区溢出漏洞自动化利用

* <img src="image/pdf_24px.png">[Paper](./paper/2019基于符号执行的缓冲区溢出漏洞自动化利用.pdf)

**Abstract:** 软件规模与数量的快速增长给软件安全研究带来了严峻的挑战，以人工方式分析漏洞已难以完成漏洞危害性的评估。分析缓冲区溢出漏洞的形成原理，提出一种缓冲区溢出漏洞自动化利用方法。该方法采用符号执行检测漏洞，为缓解符号执行中状态爆炸问题，使用危险函数切片减少状态数量。对于检测到的漏洞，通过构建约束表达式和约束求解自动生成exploit。针对进程中不存在空间足够的可控内存块的情况，以shellcode分段存放的方式利用漏洞。实验结果表明，该方法可有效缓解符号执行路径爆炸问题，自动检测漏洞并生成适用性较好的exploit。

### 有限资源条件下的软件漏洞自动挖掘与利用

* <img src="image/pdf_24px.png">[Paper](./paper/2019有限资源条件下的软件漏洞自动挖掘与利用.pdf)

**Abstract:** 漏洞是系统安全与攻防对抗的核心要素，漏洞的自动发现、分析、利用是长期以来研究的热点和难点，现有研究主要集中在模糊测试、污点分析、符号执行等方面．当前研究一方面主要从漏洞的发现、分析和利用的不同环节提出了一系列解决方案，缺乏系统性的研究和实现；另一方面相关方法未考虑现实环境的有限资源条件，其中模糊测试主要基于大规模的服务器集群实施，污点分析和符号执行方法时间与空间复杂度高，且容易出现状态爆炸针对有限资源条件下的漏洞自动挖掘与利用问题，建立了Weak-Tainted程序运行时漏洞模型，提出了一套面向漏洞自动挖掘、分析、利用的完整解决方案；提出了污点传播分析优化方法和基于输出特征反馈的输入求解方法等有限资源条件下的分析方案，提升了漏洞挖掘分析与利用生成能力；实现了漏洞自动挖掘和利用原型系统，单台服务器设备可并发运行25个漏洞挖掘与分析任务对2018年BCTF比赛样本进行了实验对比测试，该输入求解方法在求解atoi，hex，base64编码的能力均优于ANGR，同等漏洞挖掘能力条件下效率比AFL提高45.7％，测试的50个样本中有24个能够自动生成利用代码，验证了Weak-Tainted漏洞描述模型用于漏洞自动挖掘和利用生成的优势。

### Automatic exploit generation for buffer overflow vulnerability

* <img src="image/pdf_24px.png">[Paper](./paper/2018automatic%20exploit%20generation%20for%20buffer%20overflow%20vulnerability.pdf)

**Abstract:** Buffer overflow vulnerabilities are widely found in software. Finding these vulnerabilities and identifying whether these vulnerabilities can be exploit is very important. However, it is not easy to find all of the buffer overflow vulnerabilities in software programs, and it is more difficult to find and exploit these vulnerabilities in binary programs. This paper proposes a method and a corresponding tool that automatically finds buffer overflow vulnerabilities in binary programs, and then automatically generate exploit for the vulnerability. The tool uses symbolic execution to search the target software and find potential buffer overflow vulnerabilities, then try to bypass system protection by choosing different exploiting method according to the different level of protections. Finally, the exploit of software vulnerability is generated using constraint solver. The method and tool can automatically find vulnerabilities and generate exploits for three kinds of protection: without system protection, with address space layout randomization protection, and with stack non-executable protection.

### Automatic Heap Layout Manipulation for Exploitation

* <img src="image/pdf_24px.png">[Paper](./paper/2018Automatic%20Heap%20Layout%20Manipulation%20for%20Exploitation.pdf)

**Abstract:** Heap layout manipulation is integral to exploiting heapbased memory corruption vulnerabilities. In this paper we present the first automatic approach to the problem, based on pseudo-random black-box search. Our approach searches for the inputs required to place the source of a heap-based buffer overflow or underflow next to heap-allocated objects that an exploit developer, or automatic exploit generation system, wishes to read or corrupt. We present a framework for benchmarking heap layout manipulation algorithms, and use it to evaluate our approach on several real-world allocators, showing that pseudo-random black box search can be highly effective. We then present SHRIKE, a novel system that can perform automatic heap layout manipulation on the PHP interpreter and can be used in the construction of controlflow hijacking exploits. Starting from PHP’s regression tests, SHRIKE discovers fragments of PHP code that interact with the interpreter’s heap in useful ways, such as making allocations and deallocations of particular sizes, or allocating objects containing sensitive data, such as pointers. SHRIKE then uses our search algorithm to piece together these fragments into programs, searching for one that achieves a desired heap layout. SHRIKE allows an exploit developer to focus on the higher level concepts in an exploit, and to defer the resolution of heap layout constraints to SHRIKE. We demonstrate this by using SHRIKE in the construction of a control-flow hijacking exploit for the PHP interpreter.

### Block Oriented Programming: Automating Data-Only Attacks

* <img src="image/pdf_24px.png">[Paper](./paper/2018Block%20oriented%20programming%20automating%20data-only%20attacks.pdf)

**Abstract:** With the widespread deployment of Control-Flow Integrity (CFI), control-flow hijacking attacks, and consequently code reuse attacks, are significantly more difficult. CFI limits control flow to well-known locations, severely restricting arbitrary code execution. Assessing the remaining attack surface of an application under advanced control-flow hijack defenses such as CFI and shadow stacks remains an open problem. We introduce BOPC, a mechanism to automatically assess whether an attacker can execute arbitrary code on a binary hardened with CFI/shadow stack defenses. BOPC computes exploits for a target program from payload specifications written in a Turingcomplete, high-level language called SPL that abstracts away architecture and program-specific details. SPL payloads are compiled into a program trace that executes the desired behavior on top of the target binary. The input for BOPC is an SPL payload, a starting point (e.g., from a fuzzer crash) and an arbitrary memory write primitive that allows application state corruption. To map SPL payloads to a program trace, BOPC introduces Block Oriented Programming (BOP), a new code reuse technique that utilizes entire basic blocks as gadgets along valid execution paths in the program, i.e., without violating CFI or shadow stack policies. We find that the problem of mapping payloads to program traces is NP-hard, so BOPC first reduces the search space by pruning infeasible paths and then uses heuristics to guide the search to probable paths. BOPC encodes the BOP payload as a set of memory writes. We execute 13 SPL payloads applied to 10 popular applications. BOPC successfully finds payloads and complex execution traces - which would likely not have been found through manual analysis - while following the target’s Control-Flow Graph under an ideal CFI policy in 81% of the cases.

### End-to-End Automated Exploit Generation for Validating the Security of Processor Designs

* <img src="image/pdf_24px.png">[Paper](./paper/2018End-to-End%20Automated%20Exploit%20Generation%20for%20Validating%20the%20Security%20of%20Processor%20Designs.pdf)

**Abstract:** This paper presents Coppelia, an end-to-end tool that, given a processor design and a set of security-critical invariants, automatically generates complete, replayable exploit programs to help designers find, contextualize, and assess the security threat of hardware vulnerabilities. In Coppelia, we develop a hardware-oriented backward symbolic execution engine with a new cycle stitching method and fast validation technique, along with several optimizations for exploit generation. We then add program stubs to complete the exploit. We evaluate Coppelia on three CPUs of different architectures. Coppelia is able to find and generate exploits for 29 of 31 known vulnerabilities in these CPUs, including 11 vulnerabilities that commercial and academic model checking tools can not find. All of the generated exploits are successfully replayable on an FPGA board.Moreover, Coppelia finds 4 new vulnerabilities along with exploits in these CPUs. We also use Coppelia to verify whether a security patch indeed fixed a vulnerability, and to refine a set of assertions.

### FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2018FUZE%20Towards%20Facilitating%20Exploit%20Generation%20for%20Kernel%20Use-After-Free%20Vulnerabilities.pdf)

**Abstract:** Software vendors usually prioritize their bug remediation based on ease of their exploitation. However, accurately determining exploitability typically takes tremendous hours and requires significant manual efforts. To address this issue, automated exploit generation techniques can be adopted. In practice, they however exhibit an insufficient ability to evaluate exploitability particularly for the kernel Use-After-Free (UAF) vulnerabilities. This is mainly because of the complexity of UAF exploitation as well as the scalability of an OS kernel. In this paper, we therefore propose FUZE, a new framework to facilitate the process of kernel UAF exploitation. The design principle behind this technique is that we expect the ease of crafting an exploit could augment a security analyst with the ability to evaluate the exploitability of a kernel UAF vulnerability. Technically, FUZE utilizes kernel fuzzing along with symbolic execution to identify, analyze and evaluate the system calls valuable and useful for kernel UAF exploitation. In addition, it leverages dynamic tracing and an off-the-shelf constraint solver to guide the manipulation of vulnerable object. To demonstrate the utility of FUZE, we implement FUZE on a 64-bit Linux system by extending a binary analysis framework and a kernel fuzzer. Using 15 realworld kernel UAF vulnerabilities on Linux systems, we then demonstrate FUZE could not only escalate kernel UAF exploitability but also diversify working exploits. In addition, we show that FUZE could facilitate security mitigation bypassing, making exploitability evaluation less challenging and more efficient.

### Heaphopper: Bringing Bounded Model Checking to Heap Implementation Security

* <img src="image/pdf_24px.png">[Paper](./paper/2018HEAPHOPPER%20Bringing%20Bounded%20Model%20Checking%20to%20Heap%20Implementation%20Security.pdf)

**Abstract:** Heap metadata attacks have become one of the primary ways in which attackers exploit memory corruption vulnerabilities. While heap implementation developers have introduced mitigations to prevent and detect corruption, it is still possible for attackers to work around them. In part, this is because these mitigations are created and evaluated without a principled foundation, resulting, in many cases, in complex, inefficient, and ineffective attempts at heap metadata defenses. In this paper, we present HEAPHOPPER, an automated approach, based on model checking and symbolic execution, to analyze the exploitability of heap implementations in the presence of memory corruption. Using HEAPHOPPER, we were able to perform a systematic analysis of different, widely used heap implementations, finding surprising weaknesses in them. Our results show, for instance, how a newly introduced cachingmechanismin ptmalloc (the heap allocator implementation used bymost of the Linux distributions) significantly weakens its security. Moreover, HEAPHOPPER guided us in implementing and evaluating improvements to the security of ptmalloc, replacing an ineffective recent attempt at the mitigation of a specific form of heap metadata corruption with an effective defense.

### NAVEX: Precise and Scalable Exploit Generation for Dynamic Web Applications

* <img src="image/pdf_24px.png">[Paper](./paper/2018NAVEX--Precise%20and%20Scalable%20Exploit%20Generation%20for%20Dynamic%20Web%20Applications.pdf)

**Abstract:** Modern multi-tier web applications are composed of several dynamic features, which make their vulnerability analysis challenging from a purely static analysis perspective. We describe an approach that overcomes the challenges posed by the dynamic nature of web applications. Our approach combines dynamic analysis that is guided by static analysis techniques in order to automatically identify vulnerabilities and build working exploits. Our approach is implemented and evaluated in NAVEX, a tool that can scale the process of automatic vulnerability analysis and exploit generation to large applications and to multiple classes of vulnerabilities. In our experiments, we were able to use NAVEX over a codebase of 3.2 million lines of PHP code, and construct 204 exploits in the code that was analyzed.

### Pangr: A Behavior-based Automatic Vulnerability Detection and Exploitation Framework

* <img src="image/pdf_24px.png">[Paper](./paper/2018Pangr-%20A%20Behavior-Based%20Automatic%20Vulnerability%20Detection%20and%20Exploitation%20Framework.pdf)

**Abstract:** Nowadays, with the size and complexity of software increasing rapidly, vulnerabilities are becoming diversified and hard to identify. It is unpractical to detect and exploit vulnerabilities by manual construction. Therefore, an efficient automatic method of detecting and exploiting software vulnerability is in critical demand. This paper implements Pangr, an entire system for automatic vulnerability detection, exploitation, and patching. Pangr builds a complete vulnerability model based on its triggering behavior to identify vulnerabilities and generate exp or exploit schemes. According to the type and feature of the vulnerability, Pangr can generate the specific patch for the software. In the experiment, we tested 20 vulnerable programs on 32-bit Linux machine. Pangr detected 16 vulnerabilities, generated 10 exp, and patched 14 programs.

### Revery: From Proof-of-Concept to Exploitable

* <img src="image/pdf_24px.png">[Paper](./paper/2018Revery%20From%20Proof-of-Concept%20to%20Exploitable.pdf)

**Abstract:** Automatic exploit generation is an open challenge. Existing solutions usually explore in depth the crashing paths, i.e., paths taken by proof-of-concept (PoC) inputs triggering vulnerabilities, and generate exploits when exploitable states are found along the paths. However, exploitable states do not always exist in crashing paths. Moreover, existing solutions heavily rely on symbolic execution and are not scalable in path exploration and exploit generation. In addition, few solutions could exploit heap-based vulnerabilities. In this paper, we propose a new solution Revery to search for exploitable states in paths diverging from crashing paths, and generate control-flow hijacking exploits for heap-based vulnerabilities. It adopts three novel techniques: (1) a layout-contributor digraph to characterize a vulnerability’s memory layout and its contributor instructions; (2) a layout-oriented fuzzing solution to explore diverging paths, which have similar memory layouts as the crashing paths, in order to search more exploitable states and generate corresponding diverging inputs; (3) a control-flow stitching solution to stitch crashing paths and diverging paths together, and synthesize EXP inputs able to trigger both vulnerabilities and exploitable states. We have developed a prototype of Revery based on the binary analysis engine angr, and evaluated it on a set of 19 CTF (capture the flag) programs. Experiment results showed that it could generate exploits for 9 (47%) of them, and generate EXP inputs able to trigger exploitable states for another 5 (26%) of them.

### Survey of Automated Vulnerability Detection and Exploit Generation Techniques in Cyber Reasoning Systems

* <img src="image/pdf_24px.png">[Paper](./paper/2018Survey%20of%20Automated%20Vulnerability%20Detection%20and%20Exploit%20Generation%20Techniques%20in%20Cyber%20Reasoning%20Systems.pdf)

**Abstract:** Software is everywhere, from mission critical systems such as industrial power stations, pacemakers and even household appliances. This growing dependence on technology and the increasing complexity of software has serious security implications as it means we are potentially surrounded by software that contains exploitable vulnerabilities. These challenges have made binary analysis an important area of research in computer science and has emphasized the need for building automated analysis systems that can operate at scale, speed and efficiency; all while performing with the skill of a human expert. Though great progress has been made in this area of research, there remains limitations and open challenges to be addressed. Recognizing this need, DARPA sponsored the Cyber Grand Challenge (CGC), a competition to showcase the current state of the art in systems that perform; automated vulnerability detection, exploit generation and software patching. This paper is a survey of the vulnerability detection and exploit generation techniques, underlying technologies and related works of two of the winning systems Mayhem and Mechanical Phish.

### TEETHER: Gnawing at Ethereum to Automatically Exploit Smart Contracts

* <img src="image/pdf_24px.png">[Paper](./paper/2018teEther-%20Gnawing%20at%20Ethereum%20to%20Automatically%20Exploit%20Smart%20Contracts.pdf)

**Abstract:** Cryptocurrencies like Bitcoin not only provide a decentralized currency, but also provide a programmatic way to process transactions. Ethereum, the second largest cryptocurrency next to Bitcoin, is the first to provide a Turing-complete language to specify transaction processing, thereby enabling so-called smart contracts. This provides an opportune setting for attackers, as security vulnerabilities are tightly intertwined with financial gain. In this paper, we consider the problem of automatic vulnerability identification and exploit generation for smart contracts. We develop a generic definition of vulnerable contracts and use this to build TEETHER, a tool that allows creating an exploit for a contract given only its binary bytecode. We perform a large-scale analysis of all 38,757 unique Ethereum contracts, 815 out of which our tool finds working exploits for—completely automated.

### Towards Automated Generation of Exploitation Primitives for Web Browsers

* <img src="image/pdf_24px.png">[Paper](./paper/2018Towards%20Automated%20Generation%20of%20Exploitation%20Primitives%20for%20Web%20Browsers.pdf)

**Abstract:** The growing dependence on software and the increasing complexity of such systems builds and feeds the attack surface for exploitable vulnerabilities. Security researchers put up a lot of effort to develop exploits and analyze existing exploits with the goal of staying ahead of the state-of-the-art in attacks and defenses. The urge for automated systems that operate at scale, speed and efficiency is therefore undeniable. Given their complexity and large user base, web browsers pose an attractive target. Due to various mitigation strategies, the exploitation of a browser vulnerability became a time consuming, multi-step task: creating a working exploit even from a crashing input is a resource-intensive task that can take a substantial amount of time to complete. In many cases, the input, which triggers a vulnerability follows a crashing path but does not enter an exploitable state. In this paper, we introduce novel methods to significantly improve and partially automate the development process for browser exploits. Our approach is based on the observation that an analyst typically performs certain manual analysis steps that can be automated. This serves the purpose to propagate the bug-induced, controlled data to a specific program location to carry out a desired action. These actions include achieving write-what-where or control over the instruction pointer primitives. These are useful to extend control over the target program and are necessities towards successful code execution, the ultimate goal of the adversary.We implemented a prototype of our approach called PrimGen. For a given browser vulnerability, it is capable of automatically crafting data objects that lead the execution to a desired action. We show in our evaluation that our approach is able to generate new and previously unknown exploitation opportunities for real-world vulnerabilities in Mozilla Firefox, Internet Explorer, and Google Chrome. Using small templates, PrimGen generates inputs that conducts specific primitives. In total, PrimGen has found 48 JavaScript inputs which conduct the desired primitives when fed into the target browsers.

### Automatic Generation of Inter-Component Communication Exploits for Android Applications

* <img src="image/pdf_24px.png">[Paper](./paper/2017Automatic%20Generation%20of%20Inter-Component%20Communication.pdf)

**Abstract:** Although a wide variety of approaches identify vulnerabilities in Android apps, none attempt to determine exploitability of those vulnerabilities. Exploitability can aid in reducing false positives of vulnerability analysis, and can help engineers triage bugs. Specifically, one of the main attack vectors of Android apps is their inter-component communication interface, where apps may receive messages called Intents. In this paper, we provide the first approach for automatically generating exploits for Android apps, called LetterBomb, relying on a combined path-sensitive symbolic execution-based static analysis, and the use of software instrumentation and test oracles. We run LetterBomb on 10,000 Android apps from Google Play, where we identify 181 exploits from 835 vulnerable apps. Compared to a state-of-the-art detection approach for three ICC-based vulnerabilities, LetterBomb obtains 33%-60% more vulnerabilities at a 6.66 to 7 times faster speed.

### Automatic Generation of Tests to Exploit XML Injection Vulnerabilities in Web Applications

* <img src="image/pdf_24px.png">[Paper](./paper/2017Automatic%20Generation%20of%20Tests%20to%20Exploit%20XML%20Injection%20Vulnerabilities%20in%20Web%20Applications.pdf)

**Abstract:** Modern enterprise systems can be composed of many web services (e.g., SOAP and RESTful). Users of such systems might not have direct access to those services, and rather interact with them through a single-entry point which provides a GUI (e.g., a web page or a mobile app). Although the interactions with such entry point might be secure, a hacker could trick such systems to send malicious inputs to those internal web services. A typical example is XML injection targeting SOAP communications. Previous work has shown that it is possible to automatically generate such kind of attacks using search-based techniques. In this paper, we improve upon previous results by providing more efficient techniques to generate such attacks. In particular, we investigate four different algorithms and two different fitness functions. A large empirical study, involving also two industrial systems, shows that our technique is effective at automatically generating XML injection attacks.

### Automatically Assessing Crashes from Heap Overflows

* <img src="image/pdf_24px.png">[Paper](./paper/2017Automatically%20Assessing%20Crashes%20from%20Heap%20Overflows.pdf)

**Abstract:** Heap overflow is one of the most widely exploited vulnerabilities, with a large number of heap overflow instances reported every year. It is important to decide whether a crash caused by heap overflow can be turned into an exploit. Efficient and effective assessment of exploitability of crashes facilitates to identify severe vulnerabilities and thus prioritize resources. In this paper, we propose the first metrics to assess heap overflow crashes based on both the attack aspect and the feasibility aspect. We further present HCSIFTER, a novel solution to automatically assess the exploitability of heap overflow instances under our metrics. Given a heap-based crash, HCSIFTER accurately detects heap overflows through dynamic execution without any source code or debugging information. Then it uses several novel methods to extract program execution information needed to quantify the severity of the heap overflow using our metrics. We have implemented a prototype HCSIFTER and applied it to assess nine programs with heap overflow vulnerabilities. HCSIFTER successfully reports that five heap overflow vulnerabilities are highly exploitable and two overflow vulnerabilities are unlikely exploitable. It also gave quantitatively assessments for other two programs. On average, it only takes about two minutes to assess one heap overflow crash. The evaluation result demonstrates both effectiveness and efficiency of HCSIFTER.

### Construct Exploit Constraint in Crash Analysis by Bypassing Canary

* <img src="image/pdf_24px.png">[Paper](./paper/2017Construct%20exploit%20constraint%20in%20crash%20analysis%20by%20bypassing%20canary.pdf)

**Abstract:** Selective symbolic execution is a common program testing technology. Developed on the basis of it, some crash analysis systems are often used to test the fragility of the program by constructing exploit constraints, such as CRAX. From the study of crash analysis based on symbolic execution, this paper find that this technology cannot bypass the canary stack protection mechanisms. This paper makes the improvement uses the API hook in Linux. Experimental results show that the use of API hook can effectively solve the problem that crash analysis cannot bypass the canary protection.

### Modular Synthesis of Heap Exploits

* <img src="image/pdf_24px.png">[Paper](./paper/2017Modular%20synthesis%20of%20heap%20exploits.pdf)

**Abstract:** Memory errors continue to compromise the security of today’s systems. Recent efforts to automatically synthesize exploits for stack-based buffer overflows promise to help assess a vulnerability’s severity more quickly and alleviate the burden of manual reasoning. However, generation of heap exploits has been out of scope for such methods thus far. In this paper, we investigate the problem of automatically generating heap exploits, which, in addition to finding the vulnerability, requires intricate interaction with the heap manager. We identify the challenges involved in automatically finding the right parameters and interaction sequences for such attacks, which have traditionally required manual analysis. To tackle these challenges, we present a modular approach that is designed to minimize the assumptions made about the heap manager used by the target application. Our prototype system is able to find exploit primitives in six binary implementations of Windows and UNIX-based heap managers and applies these to successfully exploit two real-world applications.

### System Service Call-oriented Symbolic Execution of Android Framework with Applications to Vulnerability Discovery and Exploit Generation

* <img src="image/pdf_24px.png">[Paper](./paper/2017System%20Service%20Call-oriented%20Symbolic%20Execution%20of%20Android%20Framework%20with%20Applications%20to%20Vulnerability%20Discovery%20and%20Exploit%20Generation.pdf)

**Abstract:** Android Application Framework is an integral and foundational part of the Android system. Each of the 1.4 billion Android devices relies on the system services of Android Framework to manage applications and system resources. Given its critical role, a vulnerability in the framework can be exploited to launch large-scale cyber attacks and cause severe harms to user security and privacy. Recently, many vulnerabilities in Android Framework were exposed, showing that it is vulnerable and exploitable. However, most of the existing research has been limited to analyzing Android applications, while there are very few techniques and tools developed for analyzing Android Framework. In particular, to our knowledge, there is no previous work that analyzes the framework through symbolic execution, an approach that has proven to be very powerful for vulnerability discovery and exploit generation. We design and build the first system, Centaur, that enables symbolic execution of Android Framework. Due to some unique characteristics of the framework, such as its middleware nature and extraordinary complexity, many new challenges arise and are tackled in Centaur. In addition, we demonstrate how the system can be applied to discovering new vulnerability instances, which can be exploited by several recently uncovered attacks against the framework, and to generating PoC exploits.

### Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying

* <img src="image/pdf_24px.png">[Paper](./paper/2017Unleashing%20Use-Before-Initialization%20Vulnerabilities%20in%20the%20Linux%20Kernel%20Using%20Targete.pdf)

**Abstract:** A common type of memory error in the Linux kernel is using uninitialized variables (uninitialized use). Uninitialized uses not only cause undefined behaviors but also impose a severe security risk if an attacker takes control of the uninitialized variables. However, reliably exploiting uninitialized uses on the kernel stack has been considered infeasible until now since the code executed prior to triggering the vulnerability must leave an attacker-controlled pattern on the stack. Therefore, uninitialized uses are largely overlooked and regarded as undefined behaviors, rather than security vulnerabilities. In particular, full memorysafety techniques (e.g., SoftBound+CETS) exclude uninitialized use as a prevention target, and widely used systems such as OpenSSL even use uninitialized memory as a randomness source. In this paper, we propose a fully automated targeted stackspraying approach for the Linux kernel that reliably facilitates the exploitation of uninitialized uses. Our targeted stack-spraying includes two techniques: (1) a deterministic stack spraying technique that suitably combines tailored symbolic execution and guided fuzzing to identify kernel inputs that user-mode programs can use to deterministically guide kernel code paths and thereby leave attacker-controlled data on the kernel stack, and (2) an exhaustive memory spraying technique that uses memory occupation and pollution to reliably control a large region of the kernel stack. We show that our targeted stack-spraying approach allows attackers to reliably control more than 91% of the Linux kernel stack, which, in combination with uninitialized-use vulnerabilities, suffices for a privilege escalation attack. As a countermeasure, we propose a compiler-based mechanism that initializes potentially unsafe pointer-type fields with almost no performance overhead. Our results show that uninitialized use is a severe attack vector that can be readily exploited with targeted stack-spraying, so future memory-safety techniques should consider it a prevention target, and systems should not use uninitialized memory as a randomness source.

### Your Exploit is Mine: Automatic Shellcode Transplant for Remote Exploits

* <img src="image/pdf_24px.png">[Paper](./paper/2017Your%20Exploit%20is%20Mine%20Automatic%20Shellcode%20Transplant%20for%20Remote%20Exploits.pdf)

**Abstract:** Developing a remote exploit is not easy. It requires a comprehensive understanding of a vulnerability and delicate techniques to bypass defense mechanisms. As a result, attackers may prefer to reuse an existing exploit and make necessary changes over developing a new exploit from scratch. One such adaptation is the replacement of the original shellcode (i.e., the attacker-injected code that is executed as the final step of the exploit) in the original exploit with a replacement shellcode, resulting in a modified exploit that carries out the actions desired by the attacker as opposed to the original exploit author. We call this a shellcode transplant. Current automated shellcode placement methods are insufficient because they over-constrain the replacement shellcode, and so cannot be used to achieve shellcode transplant. For example, these systems consider the shellcode as an integrated memory chunk, and require that the execution path of the modified exploit must be same as the original one. To resolve these issues, we present ShellSwap, a system that uses symbolic tracing, with a combination of shellcode layout remediation and path kneading to achieve shellcode transplant. We evaluated the ShellSwap system on a combination of 20 exploits and 5 pieces of shellcode that are independently developed and different from the original exploit. Among the 100 test cases, our system successfully generated 85% of the exploits.

### 基于符号执行的自动利用生成系统

* <img src="image/pdf_24px.png">[Paper](./paper/2017基于符号执行的自动利用生成系统.pdf)

**Abstract:** 在本文中, 我们提出BAEG, 一个自动寻找二进制程序漏洞利用的系统. BAEG为发现的每一个漏洞产生一个控制流劫持的利用, 因此保证了它所发现的漏洞都是安全相关并且可利用的. BAEG针对输入造成程序崩溃的情况进行分析, 面临的挑战主要有两点: 1) 如何重现崩溃路径, 获取崩溃状态; 2) 如何自动生成控制流劫持利用. 对于第一点, 本论文提出路径导向算法, 将崩溃输入作为符号值, 重现崩溃路径. 对于第二点, 我们总结多种控制流劫持的利用原理, 建立对应的利用产生模型. 此外, 对于非法符号读、写操作, BAEG还可以让程序从崩溃点继续执行,探索程序深层次代码, 检测崩溃路径逻辑深处是否还有利用点.

### Chainsaw: Chained Automated Workflow-based Exploit Generation

* <img src="image/pdf_24px.png">[Paper](./paper/2016Chainsaw-%20Chained%20Automated%20Workflow-based%20Exploit%20Generation.pdf)

**Abstract:** We tackle the problem of automated exploit generation for web applications. In this regard, we present an approach that significantly improves the state-of-art in web injection vulnerability identification and exploit generation. Our approach for exploit generation tackles various challenges associated with typical web application characteristics: their multi-module nature, interposed user input, and multi-tier architectures using a database backend. Our approach develops precise models of application workflows, database schemas, and native functions to achieve high quality exploit generation. We implemented our approach in a tool called Chainsaw. Chainsaw was used to analyze 9 open source applications and generated over 199 first- and second-order injection exploits combined, significantly outperforming several related approaches.

### Data-oriented programming: On the expressiveness of non-control data attacks

* <img src="image/pdf_24px.png">[Paper](./paper/2016Data-Oriented%20Programming-%20On%20the%20Expressiveness%20of%20Non-control%20Data%20Attacks.pdf)

**Abstract:** As control-flow hijacking defenses gain adoption, it is important to understand the remaining capabilities of adversaries via memory exploits. Attacks targeting non-control data in memory can exhibit information leakage or privilege escalation. Compared to control-flow hijacking attacks, such noncontrol data exploits have limited expressiveness; however, the question is: what is the real expressive power of non-control data attacks? In this paper we show that such attacks are Turing-complete. We present a systematic technique called dataoriented programming (DOP) to construct expressive non-control data exploits for arbitrary x86 programs. In the experimental evaluation using 9 programs, we identified 7518 data-oriented x86 gadgets and 5052 gadget dispatchers, which are the building blocks for DOP . 8 out of 9 real-world programs have gadgets to simulate arbitrary computations and 2 of them are confirmed to be able to build Turing-complete attacks. We build 3 end-toend attacks to bypass randomization defenses without leaking addresses, to run a network bot which takes commands from the attacker, and to alter the memory permissions. All the attacks work in the presence of ASLR and DEP, demonstrating how the expressiveness offered by DOP significantly empowers the attacker.

### Deduplication and Exploitability Determination of UAF Vulnerability Samples by Fast Clustering

* <img src="image/pdf_24px.png">[Paper](./paper/2016Deduplication%20and%20Exploitability%20Determination%20of%20UAF%20Vulnerability%20Samples%20by%20Fast%20Clustering.pdf)

**Abstract:** Use-After-Free (UAF) is a common lethal form of software vulnerability. By using tools such as Web Browser Fuzzing, a large amount of samples containing UAF vulnerabilities can be generated. To evaluate the threat level of vulnerability or to patch the vulnerabilities, automatic deduplication and exploitability determination should be carried out for these samples. There are some problems existing in current methods, including inadequate pertinence, lack of depth and precision of analysis, high time cost, and low accuracy. In this paper, in terms of key dangling pointer and crash context, we analyze four properties of similar samples of UAF vulnerability, explore the method of extracting and calculate clustering eigenvalues from these samples, perform clustering by fast search and find of density peaks on a large number of vulnerability samples. Samples were divided into different UAF vulnerability categories according to the clustering results, and the exploitability of these UAF vulnerabilities was determined by observing the shape of class cluster. Experimental results showed that the approach was applicable to the deduplication and exploitability determination of a large amount of UAF vulnerability samples, with high accuracy and low performance cost.

### Sok: state of the art of war Offensive techniques in binary analysis

* <img src="image/pdf_24px.png">[Paper](./paper/2016SOK%20(State%20of)%20The%20Art%20of%20War%20Offensive%20Techniques%20in%20Binary%20Analysis.pdf)

**Abstract:** Finding and exploiting vulnerabilities in binary code is a challenging task. The lack of high-level, semantically rich information about data structures and control constructs makes the analysis of program properties harder to scale. However, the importance of binary analysis is on the rise. In many situations binary analysis is the only possible way to prove (or disprove) properties about the code that is actually executed. In this paper, we present a binary analysis framework that implements a number of analysis techniques that have been proposed in the past. We present a systematized implementation of these techniques, which allows other researchers to compose them and develop new approaches. In addition, the implementation of these techniques in a unifying framework allows for the direct comparison of these approaches and the identification of their advantages and disadvantages. The evaluation included in this paper is performed using a recent dataset created by DARPA for evaluating the effectiveness of binary vulnerability analysis techniques. Our framework has been open-sourced and is available to the security community.

### Towards Automated Exploit Generation for Embedded Systems

* <img src="image/pdf_24px.png">[Paper](./paper/2016Towards%20Automated%20Exploit%20Generation%20for%20Embedded%20Systems.pdf)

**Abstract:** Manual vulnerability discovery and exploit development on an executable are very challenging tasks for developers. Therefore, the automation of those tasks is becoming interesting in the field of software security. In this paper, we implement an approach of automated exploit generation for firmware of embedded systems by extending an existing dynamic analysis framework called Avatar. Embedded systems occupy a significant portion of the market but lack typical security features found on general purpose computers, making them prone to critical vulnerabilities. We discuss several techniques to automatically discover vulnerabilities and generate exploits for embedded systems, and evaluate our proposed approach by generating exploits for two vulnerable firmware written for a popular ARM Cortex-M3 microcontroller.

### 基于指针时空分析的软件异常可利用性判定

* <img src="image/pdf_24px.png">[Paper](./paper/2016基于指针时空分析的软件异常可利用性判定_彭建山.pdf)

**Abstract:** 软件异常的可利用性是评估漏洞威胁等级的重要指标。针对目前二进制程序异常可利用性判定方法存在检测模式少、分析深度和精度不足、准确率低的问题，通过分析多重指针的时空局部有效性，利用独立可控数据的内存布局构造从异常指令到跳转指令的指针引用路径，能够快速收敛搜索域，提高控制流劫持成功率和判定准确率。实验结果表明，该方法适用于栈溢出、堆溢出、整型溢出导致覆盖返回地址、函数指针等模式，具有较高的准确率和较小的性能开销。

### Automated Exploit Generation for Stack Buffer Overflow Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2015Automated%20Exploit%20Generation%20for%20Stack%20Buffer%20Overflow%20Vulnerabilities.pdf)

**Abstract:** An automated method for e xploit ge ne ration is prese nted. This method allows one to construct exploits for stack buffer overflow vulnerabilities and to prioritize software bugs. The method is based on the dynamic analysis and symbolic execution of programs. It could be applied to program binaries and does not require debug information. The proposed method was used to develop a tool for exploit generation. This tool was used to generate exploits for eight vulnerabilities in Linux and Windows programs, of which three were not fixed at the time this paper was written.

### Automatic Generation of Data-Oriented Exploits

* <img src="image/pdf_24px.png">[Paper](./paper/2015Automatic%20Generation%20of%20Data-Oriented%20Exploits.pdf)

**Abstract:** As defense solutions against control-flow hijacking attacks gain wide deployment, control-oriented exploits from memory errors become difficult. As an alternative, attacks targeting non-control data do not require diverting the application’s control flow during an attack. Although it is known that such data-oriented attacks can mount significant damage, no systematic methods to automatically construct them from memory errors have been developed. In this work, we develop a new technique called data-flow stitching, which systematically finds ways to join data flows in the program to generate data-oriented exploits. We build a prototype embodying our technique in a tool called FLOWSTITCH that works directly on Windows and Linux binaries. In our experiments, we find that FLOWSTITCH automatically constructs 16 previously unknown and three known data-oriented attacks from eight real-world vulnerable programs. All the automatically-crafted exploits respect fine-grained CFI and DEP constraints, and 10 out of the 19 exploits work with standard ASLR defenses enabled. The constructed exploits can cause significant damage, such as disclosure of sensitive information (e.g., passwords and encryption keys) and escalation of privilege.

### Exploit Generation for Information Flow Leaks in Object-Oriented Programs

* <img src="image/pdf_24px.png">[Paper](./paper/2015Exploit%20Generation%20for%20Information%20Flow%20Leaks%20in.pdf)

**Abstract:** We present a method to generate automatically exploits for information flow leaks in object-oriented programs. Our approach combines self-composition and symbolic execution to compose an insecurity formula for a given information flow policy and a specification of the security level of the program locations. The insecurity formula gives then rise to a model which is used to generate input data for the exploit. A prototype tool called KEG implementing the described approach for Java programs has been developed, which generates exploits as executable JUnit tests.

### From Collision To Exploitation: Unleashing Use-After-Free Vulnerabilities in Linux Kernel

* <img src="image/pdf_24px.png">[Paper](./paper/2015From%20Collision%20To%20Exploitation%20Unleashing%20Use-After-Free%20Vulnerabilities%20in%20Linux%20Kernel.pdf)

**Abstract:** Since vulnerabilities in Linux kernel are on the increase, attackers have turned their interests into related exploitation techniques. However, compared with numerous researches on exploiting use-after-free vulnerabilities in the user applications, few efforts studied how to exploit use-after-free vulnerabilities in Linux kernel due to the difficulties that mainly come from the uncertainty of the kernel memory layout. Without specific information leakage, attackers could only conduct a blind memory overwriting strategy trying to corrupt the critical part of the kernel, for which the success rate is negligible. In this work, we present a novel memory collision strategy to exploit the use-after-free vulnerabilities in Linux kernel reliably. The insight of our exploit strategy is that a probabilistic memory collision can be constructed according to the widely deployed kernel memory reuse mechanisms, which significantly increases the success rate of the attack. Based on this insight, we present two practical memory collision attacks: An object-based attack that leverages the memory recycling mechanism of the kernel allocator to achieve freed vulnerable object covering, and a physmapbased attack that takes advantage of the overlap between the physmap and the SLAB caches to achieve a more flexible memory manipulation. Our proposed attacks are universal for various Linux kernels of different architectures and could successfully exploit systems with use-after-free vulnerabilities in kernel. Particularly, we achieve privilege escalation on various popular Android devices (kernel version>=4.3) including those with 64-bit processors by exploiting the CVE-2015-3636 use-after-free vulnerability in Linux kernel. To our knowledge, this is the first generic kernel exploit for the latest version of Android. Finally, to defend this kind of memory collision, we propose two corresponding mitigation schemes.

### Practical Exploit Generation for Intent Message Vulnerabilities in Android

* <img src="image/pdf_24px.png">[Paper](./paper/2015Practical%20Exploit%20Generation%20for%20Intent%20Message%20Vulnerabilities%20in%20Android.pdf)

**Abstract:** Android’s Inter-Component Communication (ICC) mechanism strongly relies on Intent messages. Unfortunately, due to the lack of message origin verification in Intents, application security completely relies on the programmer’s skill and attention. In this paper, we advance the state of the art by developing a method to automatically detect potential vulnerabilities and, most importantly, demonstrate whether they can be exploited or not. To this end, we adopt a formal approach to automatically produce malicious payloads that can trigger dangerous behavior in vulnerable applications. We test our methods on a representative sample of applications, and we find that 29 out of 64 tested applications are potentially vulnerable, while 26 of them are automatically proven to be exploitable.

### Static Detection and Automatic Exploitation of Intent Message Vulnerabilities in Android Applications

* <img src="image/pdf_24px.png">[Paper](./paper/2015Static%20Detection%20and%20Automatic%20Exploitation%20of%20Intent%20Message%20Vulnerabilities%20in%20Android%20Applications.pdf)

**Abstract:** Android’s Inter-Component Communication (ICC) mechanism strongly relies on Intent messages. Unfortunately, due to the lack of message origin verification in Intents, implementing security policies based on message sources is hard in practice, and completely relies on the programmer’s skill and attention. In this paper, we present a framework for automatically detecting Intent input validation vulnerabilities. We are thus able to highlight component fragments that expose vulnerable resources to possible malicious message senders. Most importantly, we advance the state of the art by developing a method to automatically demonstrate whether the identified vulnerabilities can be exploited or not, adopting a formal approach to automatically produce malicious payloads that can trigger dangerous behavior in vulnerable applications. We therefore eliminate the high rate of false positives common in previously applied methods. We test our methods on a representative sample of applications, and we find that 29 out of 64 tested applications are detected as potentially vulnerable, while 26 out of 29 can be automatically proven to be exploitable. Our experiments demonstrate the lack of exhaustive sanity checks when receiving messages from unknown sources, and stress the underestimation of this problem in real world application development.

### 基于模拟攻击的内核提权漏洞自动利用系统

* <img src="image/pdf_24px.png">[Paper](./paper/2015基于模拟攻击的内核提权漏洞自动利用系统_李晓琦.pdf)

**Abstract:** 针对Linux下的内核级提权漏洞，基于模拟攻击的漏洞检测思想，设计并开发漏洞自动利用系统KernelPET，揭示典型提权漏洞的利用过程，从而为漏洞防御提供支持．KernelPET系统与主流漏洞库exploit-db、securityfocus等衔接，模拟攻击测试近百个提权漏洞，挑选30个经典的Linux内核提权漏洞载入KernelPET漏洞代码库，并基于不同内核、不同发行版的Linux平台测试．实验结果表明，KernelPET在多类发行版Linux系统下具有较好的效果．

### Exploit Generation from Software Failures

* <img src="image/pdf_24px.png">[Paper](./paper/2014Exploit%20Generation%20from%20Software%20Failures.pdf)

**Abstract:** We normally monitor and observe failures to measure the reliability and quality of a system. On the contrary, the failures are manipulated in the debugging process for fixing the faults or by attackers for unauthorized access of the system. We review several issues to determine if the failures (especially the software crash) are reachable and controllable by an attacker. This kind of efforts is called exploitation and can be a measurement of the trustworthiness of a failed system.

### Program Crash Analysis based on Taint analysis

* <img src="image/pdf_24px.png">[Paper](./paper/2014Program%20Crash%20Analysis%20based%20on%20Taint%20analysis.pdf)

**Abstract:** Software exception analysis can not only improve software stability before putting into commercial, but also could optimize the priority of patch updates subsequently. We propose a more practical software exception analysis approach based on taint analysis, from the view that whether an exception of the software can be exploited by an attacker. It first identifies the type of exceptions, then do taint analysis on the trace that between the program entry point to exception point, and recording taint information of memory set and registers. It finally gives the result by integrating the above recording and the subsequent instructions analysis. We implement this approach to our exception analysis framework ExpTracer, and do the evaluation with some exploitable/un-exploitable exceptions which shows that our approach is more accurate in identifying exceptions compared with current tools.

### automatic exploit Generation

* <img src="image/pdf_24px.png">[Paper](./paper/2014Automatic_Exploit_Generation.pdf)

**Abstract:** none

### ROP is Still Dangerous: Breaking Modern Defenses

* <img src="image/pdf_24px.png">[Paper](./paper/2014ROP%20is%20Still%20Dangerous-%20Breaking%20Modern%20Defenses.pdf)

**Abstract:** Return Oriented Programming (ROP) has become the exploitation technique of choice for modern memory-safety vulnerability attacks. Recently, there have been multiple attempts at defenses to prevent ROP attacks. In this paper, we introduce three new attack methods that break many existing ROP defenses. Then we show how to break kBouncer and ROPecker, two recent low-overhead defenses that can be applied to legacy software on existing hardware. We examine several recent ROP attacks seen in the wild and demonstrate that our techniques successfully cloak them so they are not detected by these defenses. Our attacks apply to many CFI-based defenses which we argue are weaker than previously thought. Future defenses will need to take our attacks into account.

### Software Crash Analysis for Automatic Exploit Generation on Binary Programs

* <img src="image/pdf_24px.png">[Paper](./paper/2014Software%20Crash%20Analysis%20for%20Automatic%20Exploit%20Generation%20on%20Binary%20Programs.pdf)

**Abstract:** This paper presents a new method, capable of automatically generating attacks on binary programs from software crashes. We analyze software crashes with a symbolic failure model by performing concolic executions following the failure directed paths, using a whole system environment model and concrete address mapped symbolic memory in . We propose a new selective symbolic input method and lazy evaluation on pseudo symbolic variables to handle symbolic pointers and speed up the process. This is an end-to-end approach able to create exploits from crash inputs or existing exploits for various applications, including most of the existing benchmark programs, and several large scale applications, such as a word processor (Microsoft office word), a media player (mpalyer), an archiver (unrar), or a pdf reader (foxit). We can deal with vulnerability types including stack and heap overflows, format string, and the use of uninitialized variables. Notably, these applications have become software fuzz testing targets, but still require a manual process with security knowledge to produce mitigation-hardened exploits. Using this method to generate exploits is an automated process for software failures without source code. The proposed method is simpler, more general, faster, and can be scaled to larger programs than existing systems. We produce the exploits within one minute for most of the benchmark programs, including mplayer. We also transform existing exploits of Microsoft office word into new exploits within four minutes. The best speedup is 7,211 times faster than the initial attempt. For heap overflow vulnerability, we can automatically exploit the unlink() macro of glibc, which formerly requires sophisticated hacking efforts.

### Automatic Polymorphic Exploit Generation for Software Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2013Automatic%20Polymorphic%20Exploit%20Generation%20for%20Software%20Vulnerabilities.pdf)

**Abstract:** Generating exploits from the perspective of attackers is an effective approach towards severity analysis of known vulnerabilities. However, it remains an open problem to generate even one exploit using a program binary and a known abnormal input that crashes the program, not to mention multiple exploits. To address this issue, in this paper, we propose PolyAEG, a system that automatically generates multiple exploits for a vulnerable program using one corresponding abnormal input. To generate polymorphic exploits, we fully leverage different trampoline instructions to hijack control flow and redirect it to malicious code in the execution context. We demonstrate that, given a vulnerable program and one of its abnormal inputs, our system can generate polymorphic exploits for the program. We have successfully generated control flow hijacking exploits for 8 programs in our experiment. Particularly, we have generated 4,724 exploits using only one abnormal input for IrfanView, a widely used picture viewer.

### CRAXweb: Automatic Web Application Testing and Attack Generation

* <img src="image/pdf_24px.png">[Paper](./paper/2013CRAXweb%20Automatic%20Web%20Application%20Testing%20and%20Attack%20Generation.pdf)

**Abstract:** This paper proposes to test web applications and generate the feasible exploits automatically, including cross-site scripting and SQL injection attacks. We test the web applications with initial random inputs by detecting symbolic queries to SQL servers or symbolic responses to HTTP servers. After symbolic outputs detected, we are able to generate attack strings and reproduce the results, emulating the manual attack behavior. In contrast with other traditional detection and prevention methods, we can determine the presence of vulnerabilities and prove the feasibility of attacks. This automatic generation process is based on a dynamic software testing method-symbolic execution by S2E. We have applied this automatic process to several known vulnerabilities on large-scale open source web applications, and generated the attack strings successfully. Our method is web platform independent, covering PHP, JSP, Rails, and Django due to the supports of the whole system environment of S2E.

### Transformation-aware Exploit Generation using a HI-CFG

* <img src="image/pdf_24px.png">[Paper](./paper/2013Transformation-aware%20Exploit%20Generation%20using%20a%20HI-CFG.pdf)

**Abstract:** A common task for security analysts is to determine whether potentially unsafe code constructs (as found by static analysis or code review) can be triggered by an attackercontrolled input to the program under analysis. We refer to this problem as proof-of-concept (POC) exploit generation. Exploit generation is challenging to automate because it requires precise reasoning across a large code base; in practice it is usually a manual task. An intuitive approach to exploit generation is to break down a program’s relevant computation into a sequence of transformations that map an input value into the value that can trigger an exploit. We automate this intuition by describing an approach to discover the buffer structure (the chain of buffers used between transformations) of a program, and use this structure to construct an exploit input by inverting one transformation at a time. We propose a new program representation, a hybrid information- and control-flow graph (HI-CFG), and give algorithms to build a HI-CFG from instruction traces. We then describe how to guide program exploration using symbolic execution to efficiently search for transformation pre-images. We implement our techniques in a tool that operates on applications in x86 binary form. In two case studies we discuss how our tool creates POC exploits for (i) a vulnerability in a PDF rendering library that is reachable through multiple different transformation stages and (ii) a vulnerability in the processing stage of a specific document format in AbiWord.

### CRAX: Software Crash Analysis for Automatic Exploit Generation by Modeling Attacks as Symbolic Continuations

* <img src="image/pdf_24px.png">[Paper](./paper/2012CRAX%20Software%20Crash%20Analysis%20for%20Automatic%20Exploit%20Generation%20by%20Modeling%20Attacks%20as%20Symbolic%20Conti.pdf)

**Abstract:** We present a simple framework capable of automatically generating attacks that exploit control flow hijacking vulnerabilities. We analyze given software crashes and perform symbolic execution in concolic mode, using a whole system environment model. The framework uses an end-to-end approach to generate exploits for various applications, including 16 medium scale benchmark programs, and several large scale applications, such as Mplayer (a media player), Unrar (an archiver) and Foxit(a pdf reader), with stack/heap overflow, off-by-one overflow, use of uninitialized variable, format string vulnerabilities. Notably, these applications have been typically regarded as fuzzing preys, but still require a manual process with security knowledge to produce mitigation-hardened exploits. Using our system to produce exploits is a fully automated and straightforward process for crashed software without source. We produce the exploits within six minutes for medium scale of programs, and as long as 80 minutes for mplayer (about 500,000 LOC), after constraint reductions. Our results demonstrate that the link between software bugs and security vulnerabilities can be automatically bridged.

### Unleashing MAYHEM on Binary Code

* <img src="image/pdf_24px.png">[Paper](./paper/2012Unleashing%20Mayhem%20on%20Binary%20Code.pdf)

**Abstract:** In this paper we present MA YHEM, a new system for automatically finding exploitable bugs in binary (i.e., executable) programs. Every bug reported by MA YHEM is accompanied by a working shell-spawning exploit. The working exploits ensure soundness and that each bug report is securitycritical and actionable. MA YHEM works on raw binary code without debugging information. To make exploit generation possible at the binary-level, MA YHEM addresses two major technical challenges: actively managing execution paths without exhausting memory, and reasoning about symbolic memory indices, where a load or a store address depends on user input. To this end, we propose two novel techniques: 1) hybrid symbolic execution for combining online and offline (concolic) execution to maximize the benefits of both techniques, and 2) index-based memory modeling, a technique that allows MA YHEM to efficiently reason about symbolic memory at the binary level. We used MA YHEM to find and demonstrate 29 exploitable vulnerabilities in both Linux and Windows programs, 2 of which were previously undocumented.

### AEG: Automatic Exploit Generation

* <img src="image/pdf_24px.png">[Paper](./paper/2011AEG%20Automatic%20Exploit%20Generation.pdf)

**Abstract:** The automatic exploit generation challenge is given a program, automatically find vulnerabilities and generate exploits for them. In this paper we present AEG, the first end-to-end system for fully automatic exploit generation. We used AEG to analyze 14 open-source projects and successfully generated 16 control flow hijacking exploits. Two of the generated exploits (expect-5.43 and htget-0.93) are zero-day exploits against unknown vulnerabilities. Our contributions are: 1) we show how exploit generation for control flow hijack attacks can be modeled as a formal verification problem, 2) we propose preconditioned symbolic execution, a novel technique for targeting symbolic execution, 3) we present a general approach for generating working exploits once a bug is found, and 4) we build the first end-to-end system that automatically finds vulnerabilities and generates exploits that produce a shell.

### Automatic Construction of Jump-Oriented Programming Shellcode (on the x86)

* <img src="image/pdf_24px.png">[Paper](./paper/2011Automatic%20construction%20of%20jump-oriented%20programming%20shellcode%20(on%20the%20x86).pdf)

**Abstract:** Return-Oriented Programming (ROP) is a technique which leverages the instruction gadgets in existing libraries/executables to construct Turing complete programs. However, ROP attack is usually composed with gadgets which are ending in ret instruction without the corresponding call instruction. Based on this fact, several defense mechanisms have been proposed to detect the ROP malicious code. To circumvent these defenses, Return-Oriented Programming without returns has been proposed recently, which uses the gadgets ending in jmp instruction but with much diversity. In this paper, we propose an improved ROP techniques to construct the ROP shellcode without returns. Meanwhile we implement a tool to automatically construct the realworld Return-Oriented Programming without returns shellcode, which as demonstrated in our experiment can bypass most of the existing ROP defenses.

### Q: Exploit Hardening Made Easy

* <img src="image/pdf_24px.png">[Paper](./paper/2011Q%20Exploit%20Hardening%20Made%20Easy.pdf)

**Abstract:** Prior work has shown that return oriented programming (ROP) can be used to bypass W⊕X, a software defense that stops shellcode, by reusing instructions from large libraries such as libc. Modern operating systems have since enabled address randomization (ASLR), which randomizes the location of libc, making these techniques unusable in practice. However, modern ASLR implementations leave smaller amounts of executable code unrandomized and it has been unclear whether an attacker can use these small code fragments to construct payloads in the general case. In this paper, we show defenses as currently deployed can be bypassed with new techniques for automatically creating ROP payloads from small amounts of unrandomized code. We propose using semantic program verification techniques for identifying the functionality of gadgets, and design a ROP compiler that is resistant to missing gadget types. To demonstrate our techniques, we build Q, an end-to-end system that automatically generates ROP payloads for a given binary. Q can produce payloads for 80% of Linux /usr/bin programs larger than 20KB. We also show that Q can automatically perform exploit hardening: given an exploit that crashes with defenses on, Q outputs an exploit that bypasses both W⊕X and ASLR. We show that Q can harden nine realworld Linux and Windows exploits, enabling an attacker to automatically bypass defenses as deployed by industry for those programs.

### WAPTEC: Whitebox Analysis of Web Applications for Parameter Tampering Exploit Construction

* <img src="image/pdf_24px.png">[Paper](./paper/2011WAPTEC-%20Whitebox%20analysis%20of%20Web%20applications%20for%20parameter%20tampering%20exploit%20construction.pdf)

**Abstract:** Parameter tampering attacks are dangerous to a web application whose server fails to replicate the validation of user-supplied data that is performed by the client. Malicious users who circumvent the client can capitalize on the missing server validation. In this paper, we describe WAPTEC, a tool that is designed to automatically identify parameter tampering vulnerabilities and generate exploits by construction to demonstrate those vulnerabilities. WAPTEC involves a new approach to whitebox analysis of the server’s code. We tested WAPTEC on six open source applications and found previously unknown vulnerabilities in every single one of them.

### Crash analysis with BitBlaze

* <img src="image/pdf_24px.png">[Paper](./paper/2010Crash%20analysis%20with%20BitBlaze.pdf)

**Abstract:** The BitBlaze Binary Analysis Platform is a flexible infrastructure for analyzing off-theshelf binaries12. Binary analysis is critical for both defensive and offensive security applications: we must often analyze either malicious software or commercial vulnerable software that lack source code. However, the complexity of binary analysis has limited the development of tools in this area. The BitBlaze platform provides a toolbox of components that can be used on their own or as building blocks in new analysis systems. 

### Automatic Creation of SQL Injection and Cross-Site Scripting Attacks

* <img src="image/pdf_24px.png">[Paper](./paper/2009Automatic%20creation%20of%20SQL%20Injection%20and%20cross-site%20scripting%20attacks.pdf)

**Abstract:** We present a technique for finding security vulnerabilities in Web applications. SQL Injection (SQLI) and crosssite scripting (XSS) attacks are widespread forms of attack in which the attacker crafts the input to the application to access or modify user data and execute malicious code. In the most serious attacks (called second-order, or persistent, XSS), an attacker can corrupt a database so as to cause subsequent users to execute malicious code. This paper presents an automatic technique for creating inputs that expose SQLI and XSS vulnerabilities. The technique generates sample inputs, symbolically tracks taints through execution (including through database accesses), and mutates the inputs to produce concrete exploits. Ours is the first analysis of which we are aware that precisely addresses second-order XSS attacks. Our technique creates real attack vectors, has few false positives, incurs no runtime overhead for the deployed application, works without requiring modification of application code, and handles dynamic programming-language constructs. We implemented the technique for PHP, in a tool ARDILLA. We evaluated ARDILLA on five PHP applications and found 68 previously unknown vulnerabilities (23 SQLI, 33 first-order XSS, and 12 second-order XSS).

### Automatic Generation of Control Flow Hijacking Exploits for Software Vulnerabilities

* <img src="image/pdf_24px.png">[Paper](./paper/2009Automatic%20Generation%20of%20Control%20Flow%20Hijacking%20Exploits%20for%20Software%20Vulnerabilities.pdf)

**Abstract:** Software bugs that result in memory corruption are a common and dangerous feature of systems developed in certain programming languages. Such bugs are security vulnerabilities if they can be leveraged by an attacker to trigger the execution of malicious code. Determining if such a possibility exists is a time consuming process and requires technical expertise in a number of areas. Often the only way to be sure that a bug is in fact exploitable by an attacker is to build a complete exploit. It is this process that we seek to automate. We present a novel algorithm that integrates data-flow analysis and a decision procedure with the aim of automatically building exploits. The exploits we generate are constructed to hijack the control flow of an application and redirect it to malicious code. Our algorithm is designed to build exploits for three common classes of security vulnerability; stack-based buffer overflows that corrupt a stored instruction pointer, buffer overflows that corrupt a function pointer, and buffer overflows that corrupt the destination address used by instructions that write to memory. For these vulnerability classes we present a system capable of generating functional exploits in the presence of complex arithmetic modification of inputs and arbitrary constraints. Exploits are generated using dynamic data-flow analysis in combination with a decision procedure. To the best of our knowledge the resulting implementation is the first to demonstrate exploit generation using such techniques. We illustrate its effectiveness on a number of benchmarks including a vulnerability in a large, real-world server application.

### Return-Oriented Rootkits: Bypassing Kernel Code Integrity Protection Mechanisms

* <img src="image/pdf_24px.png">[Paper](./paper/2009Return-Oriented%20Rootkits-%20Bypassing%20Kernel%20Code%20Integrity%20Protection%20Mechanisms.pdf)

**Abstract:** Protecting the kernel of an operating system against attacks, especially injection of malicious code, is an important factor for implementing secure operating systems. Several kernel integrity protection mechanism were proposed recently that all have a particular shortcoming: They cannot protect against attacks in which the attacker re-uses existing code within the kernel to perform malicious computations. In this paper, we present the design and implementation of a system that fully automates the process of constructing instruction sequences that can be used by an attacker for malicious computations. We evaluate the system on different commodity operating systems and show the portability and universality of our approach. Finally, we describe the implementation of a practical attack that can bypass existing kernel integrity protection mechanisms.

### Automatic Generation of XSS and SQL Injection Attacks with Goal-Directed Model Checking

* <img src="image/pdf_24px.png">[Paper](./paper/2008Automatic%20Generation%20of%20XSS%20and%20SQL%20Injection%20Attacks%20with%20Goal-directed%20Model%20Checking.pdf)

**Abstract:** Cross-site scripting (XSS) and SQL injection errors are two prominent examples of taint-based vulnerabilities that have been responsible for a large number of security breaches in recent years. This paper presents QED, a goal-directed model-checking system that automatically generates attacks exploiting taint-based vulnerabilities in large Java web applications. This is the first time where model checking has been used successfully on real-life Java programsto create attack sequences that consist of multiple HTTP requests. QED accepts any Java web application that is written to the standard servlet specification. The analyst specifies the vulnerability of interest in a specification that looks like a Java code fragment, along with a range of values for form parameters. QED then generates a goal-directed analysis from the specification to perform session-aware tests, optimizes to eliminate inputs that are not of interest, and feeds the remainder to a model checker. The checker will systematically explore the remainingstate spaceandreportexampleattacksif thevulnerability specification is matched. QED provides better results than traditional analyses because it does not generate any false positive warnings. It proves the existence of errors by providing an example attack and a program trace showing how the code is compromised. Past experience suggests this is important because it makes it easy for the application maintainer to recognize the errors and to make the necessary fixes. In addition, for a class of applications, QED can guarantee that it has found all the potential bugs in the program. We have run QED over 3 Java web applications totaling 130,000 lines of code. We found 10 SQL injections and 13 cross-site scripting errors.

### Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications

* <img src="image/pdf_24px.png">[Paper](./paper/2008Automatic%20Patch-Based%20Exploit%20Generation%20is%20Possible%20Techniques%20and%20Implications.pdf)

**Abstract:** The automatic patch-based exploit generation problem is: given a program P and a patched version of the program P′, automatically generate an exploit for the potentially unknown vulnerability present in P but fixed in P′. In this paper , we propose techniques for automatic patch-based exploit generation, and show that our techniques can automatically generate exploits for 5 Microsoft programs based upon patches provided via Windows Update. Although our techniques may not work in all cases, a fundamental tenet of security is to conservatively estimate the capabilities of attackers. Thus, our results indicate that automatic patch-based exploit generation should be considered practical. One important security implication of our results is that current patch distribution schemes which stagger patch distribution over long time periods, such as Windows Update, may allow attackers who receive the patch first to compromise the significant fraction of vulnerable hosts who have not yet received the patch.

### Automating Mimicry Attacks Using Static Binary Analysis

* <img src="image/pdf_24px.png">[Paper](./paper/2005Automating%20Mimicry%20Attacks%20Using%20Static%20Binary%20Analysis.pdf)

**Abstract:** Intrusion detection systems that monitor sequences of system calls have recently become more sophisticated in defining legitimate application behavior. In particular, additional information, such as the value of the program counter and the configuration of the program’s call stack at each system call, has been used to achieve better characterization of program behavior. While there is common agreement that this additional information complicates the task for the attacker, it is less clear to which extent an intruder is constrained. In this paper, we present a novel technique to evade the extended detection features of state-of-the-art intrusion detection systems and reduce the task of the intruder to a traditional mimicry attack. Given a legitimate sequence of system calls, our technique allows the attacker to execute each system call in the correct execution context by obtaining and relinquishing the control of the application’s execution flow through manipulation of code pointers. We have developed a static analysis tool for Intel x86 binaries that uses symbolic execution to automatically identify instructions that can be used to redirect control flow and to compute the necessary modifications to the environment of the process. We used our tool to successfully exploit three vulnerable programs and evade detection by existing state-of-the-art system call monitors. In addition, we analyzed three real-world applications to verify the general applicability of our techniques.
